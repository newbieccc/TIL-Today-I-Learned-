# 정보처리기사 2024

## # 2-4. 소프트웨어 개발 - 애플리케이션 테스트 관리

### # 1. 애플리케이션 테스트 케이스 설계 2-84page

### 3. 다음 설명에 해당하는 검사는?

- 검증 검사 기법 중 개발자의 장소에서 사용자가 개발자 앞에서 행하는 기법이며, 일반적으로 통제된 환경에서 사용자와 개발자가 함께 확인하면서 수행되는 검사는?
  - `알파 검사`

```markdown
- 베타 검사는 실제 환경에서 고객에 의해 수행되는 검사(테스트)이다.
```

### 4. 테스트 케이스의 입력 값

|평가 점수|성적|
|:--:|:--:|
|80~100|A|
|60~79|B|
|0~59|C|

- 평가 점수에 따른 성적부여 표이다. 이를 구현한 소프트웨어를 경곗 값 분석 기법으로 테스트하고자 할 때 다음 중 테스트 케이스의 입력 값으로 옳지 않은 것은?
  - 90 (x)
  - 59, 80, 101 (o)

```markdown
- 블랙박스 테스트 유형 중 경곗값 분석 테스트(Boundary Value Analysis Testing)는 등가분할 후 경곗값 부분에서 오류 발생 확률이 높아서 경곗값을 포함하여 테스트 케이스를 설계하여 테스트하는 기법이다.
- 90이라는 숫자는 80~100의 경계가 아닌 가운데 값이므로 경곗값 분석 테스트라고 보기 어렵다.
- 0 : -1, 0, 1
- 60 : 59, 60, 61
- 80 : 79, 80, 81
- 100 : 99, 100, 101
```

### 5. White box Testing에 대한 설명

- White box Testing에 대한 설명
  - Source Code의 모든 문장을 한 번 이상 수행함으로써 진행된다.
  - 모듈 안의 작동을 직접 관찰할 수 있다.
  - 산출물의 각 기능별로 적절한 프로그램의 제어 구조에 따라 선택, 반복 등의 부분들을 수행함으로써 논리적 경로를 점검한다.
- Base Path Testing은 White box Testing 기법이지만,
- Boundary Value Analysis는 Black box Testing 기법이다.

### 6. 소프트웨어 테스트에서 검증(Verification)과 확인(Validation)에 대한 설명

- 소프트웨어 테스트에서 검증(Verification)과 확인(Validation)에 대한 설명
  - 소프트웨어 테스트에서 검증과 확인을 구별하면 찾고자 하는 결함 유형을 명확하게 하는 데 도움이 된다.
  - 검증은 소프트웨어 개발 과정을 테스트하는 것이고, 확인은 소프트웨어 결과를 테스트하는 것이다.
  - 검증은 작업 제품이 요구 명세의 기능, 비기능 요구사항을 얼마나 잘 준수하는지 측정하는 작업니다.

```markdown
- 검증(Verification)
  - 소프트웨어 개발 과정을 테스트
  - 올바른 제품을 생산하고 있는지 검증
  - 이전 단계에서 설정된 개발 규격과 요구를 충족시키는지 판단
  - 개발자 혹은 시험자의 시각으로 소프트웨어가 명세화된 기능을 올바른 수행하는지 알아보는 과정
- 확인(Validation)
  - 소프트웨어 결과를 테스트
  - 만들어진 제품이 제대로 동작하는지 확인
  - 최종 사용자 요구 또는 소프트웨어 요구에 적합한지 판단
  - 사용자 시각으로 올바른 소프트웨어가 개발되었는지 입증하는 과정
```

### 8. 단위 테스트를 통해 발견할 수 있는 오류

- 단위 테스트를 통해 발견할 수 있는 오류
  - 알고리즘 오류에 따른 원치 않는 결과
  - 탈출구가 없는 반복문의 사용
  - 틀린 계산 수식에 의한 잘못된 결과
- 모듈간의 인터페이스 관련 오류 및 결함을 찾아내기 위한 채계적인 테스트 기법은 통합 테스트이다.

### 10. 다음 설명에 해당하는 테스트 단계는?

- 알파, 베타 테스트와 가장 밀접한 연관이 있는 테스트 단계는?
  - `인수 테스트`

### 15. 다음이 설명하는 테스트 용어는?

```markdown
- 테스트의 결과가 참인지 거짓인지를 판단하기 위해서 사전에 정의된 참값을 입력하여 비교하는 기법 및 활동을 말한다.
- 종류에는 참, 샘플링, 휴리스틱, 일관성 검사가 존재한다.
```

- `테스트 오라클`

### 20. 테스트 케이스와 관련한 설명

- 테스트 케이스와 관련한 설명
  - 프로그램에 결함이 있더라도 입력에 대해 정상적인 결과를 낼 수 있기 때문에 결함을 검사할 수 있는 테스트 케이스를 찾는 것이 중요하다.
  - 개발된 서비스가 정의된 요구사항을 준수하는지 확인하기 위한 입력값과 실행 조건, 예상 결과의 집합으로 볼 수 있다.
  - 테스트 케이스 실행이 통과되었는지 실패하였는지 판단하기 위한 기준을 테스트 오라클(Test Oracle)이라고 한다.
  - 테스트의 목표 및 테스트 방법을 결정한 이후에 테스트 케이스를 작성한다.

```markdown
테스트 케이스 작성 절차
1. 테스트 대상 프로젝트 범위와 접근 방법 이해를 위해서 테스트 계획 검토 및 자료 확보
2. 위험 평가 및 우선순위 결정
3. 테스트 요구사항 정의
4. 테스트 구조 설계 및 테스트 방법 결정
5. 테스트 케이스 정의 및 작성
6. 테스트 케이스 타당성 확인 및 유지보수
```

### 23. 소프트웨어 생명주기 모델 중 V 모델과 관련한 설명

- 소프트웨어 생명주기 모델 중 V 모델과 관련한 설명
  - Perry에 의해 제안되었으며 세부적인 테스트 과정으로 구성되어 신뢰도 높은 시스템을 개발하는데 효과적이다.
  - 개발 작업과 검증 작업 사이의 관계를 명확히 들어내 놓은 폭포수 모델의 변형이라고 볼 수 있다.
  - 폭포수 모델이 산출물 중심이라면 V 모델은 작업과 결과의 검증에 초점을 둔다.

```markdown
- V 모델은 요구 분석 및 설계 단계를 거쳐 구현, 테스트 등 각 단계를 연결하여 V 형태를 이루는 모델이다.
- V 모델은 Perry에 의해 제안되었으며 세부적인 테스트 과정으로 구성되어 신뢰도 높은 시스템을 개발하는 데 효과적이고 개발 작업과 검증 작업 사이의 관계를 명확히 들어내 놓은 폭포수 모델의 변형이라고 볼 수 있다.
- 폭포수 모델이 산출물 중심이라면 V 모델은 작업과 결과의 검증에 초점을 둔다.
```

---

### # 2. 애플리케이션 통합 테스트 2-99page

### 3. 하향식 통합 테스트에 대한 설명

- 하향식 통합 테스트에 대한 설명
  - 시스템구조의 위층에 있는 모듈부터 아래층의 모듈로 내려오면서 통합한다.
  - 일반적으로 스텁(Stub)을 드라이버(Driver)보다 쉽게 작성할 수 있다.
  - 상위층에서 검사 사례(Test Case)를 쓰기가 어렵다.

```markdown
- 메인 제어 모듈은 작성된 프로그램을 사용하고, 아직 작성 되지 않은 하위 모듈을 제어한다.
- 스텁은 하위 모듈의 반환 값(Return Value)만 전달하면 되지만, 드라이버는 상위 모듈 흐름을 작성해야 하기 때문에 스텁이 개발하기 쉽다.
- 위에서 아래로 내려오기 때문에 검사 초기에 시스템의 구조가 파악되어야 한다.
```

### 6. 테스트 드라이버(Test Driver)에 대한 설명

- 테스트 드라이버(Test Driver)에 대한 설명
  - 시험대상 모듈을 호출하는 간이 소프트웨어이다.
  - 필요에 따라 매개 변수를 전달하고 모듈을 수행한 후에 결과를 보여줄 수 있다.
  - 상향식 통합 테스트에서 사용된다.
- 테스트 대상 모듈이 호출하는 하위 모듈의 역할을 하는 것은 테스트 스텁이다.

- 테스트 드라이버(Test Driver)
  - 상향식 통합시험을 위해 모듈 테스트 수행 후의 결과를 도출하는 시험용 모듈
  - 테스트와 필요한 모듈에 인지를 넘겨주고 테스트를 완료한 후 그 결괏값을 받는 역할을 하는 가상의 모듈
  - 하위 모듈을 호출하는 상위 모듈의 역할
- 테스트 스텁(Test Stub)
  - 하향식 통합시험을 위해 일시적으로 필요한 조건만을 가지고 임시로 제공되는 시험용 모듈
  - 상위 모듈에 의해 호출되는 하위 모듈의 역할

### 7. 테스트 케이스 자동 생성 도구를 이용하여 테스트 데이터를 찾아내는 방법

- 테스트 케이스 자동 생성 도구를 이용하여 테스트 데이터를 찾아내는 방법
  - 자료 흐름도
    - 소스 코드를 파싱하여 자료 흐름도를 작성한 후 테스트에 필요한 입력값을 찾아내는 방법
  - 기능 테스트
    - 주어진 기능을 구동시키는 상태를 파악하여 입력값을 생성하는 방법
  - 입력 도메인 분석
    - 입력 변수가 가질 수 있는 값의 도메인을 분석하는 방법
  - 랜덤 테스트
    - 입력값을 무작위로 추출하는 방법
- 스텁(Stub)과 드라이버(Driver)는 시험용 모듈

### 9. 통합 테스트(Integration Test)와 관련한 설명

- 통합 테스트(Integration Test)와 관련한 설명
  - 시스템을 구성하는 모듈의 인터페이스와 결합을 테스트하는 것이다.
  - 하향힉 통합 테스트의 경우 넓이 우선(Breadth First) 방식으로 테스트를 할 모듈을 선택할 수 있다.
  - 모듈 간의 인터페이스와 시스템의 동작이 정상적으로 잘되고 있는지를 빨리 파악하고자 할 때 상향식보다는 하향식 통합 테스트를 사용하는 것이 좋다.
  - 상향식 통합 테스트는 애플리케이션 구조에서 최하위 레벨의 모듈 또는 컴포넌트로부터 점진적으로 상위 모듈과 함께 테스트하는 기법이다.

### 10. 상향식 테스트에 필요한 것은?

```markdown
- 단위 테스트에서 테스트의 대상이 되는 하위 모듈을 호출하고, 파라미터를 전달하는 가상의 모듈로 상향식 테스트에 필요한 것은?
```

- `테스트 드라이버(Test Driver)`
- 하향식 및 상향식 통합 수행 방식(하스 상드)
  - 하향식 : 스텁
  - 상향식 : 드라이버

---

### # 3. 애플리케이션 성능 개선 2-113page

### 1. 외계인 코드(Ailen Code)에 대한 설명

- 외계인 코드(Ailen Code)에 대한 설명
  - 아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 어려운 프로그램을 의미한다.

### 3. 정렬된 N개의 데이터를 처리하는데 O(Nlog2N)의 시간이 소요되는 정렬 알고리즘은?

- 정렬된 N개의 데이터를 처리하는데 O($Nlog_2N$)의 시간이 소요되는 정렬 알고리즘은?
  - 합병 정렬

- O($nlog_2n$)
  - 퀵 정렬,
  - 병합 정렬(합병 정렬)
  - 힙 정렬
- O($n^2$)
  - 거품(버블) 정렬
  - 삽입 정렬
  - 선택 정렬

### 4. 해싱 함수 중 주소 사용 방식

- 해싱 함수 중 레코드 키를 여러 부분으로 나누고, 나눈 부분의 각 숫자를 더하거나 XOR한 값을 홈 주소로 사용하는 방식은?
  - 폴딩법

```markdown
- 제산법
  - 나머지 연산자(%)를 사용하여 테이블 주소를 계산하는 방식
- 폴딩법
  - 레코드 키를 여러 부분으로 나누고, 나눈 부분의 각 숫자를 더하거나 XOR한 값을 홈 주소로 사용하는 방식
- 기수 변환법
  - 어떤 진법으로 표현된 주어진 레코드 키를 다른 진법으로 간주하고 키를 변환하여 홈 주소를 얻는 방식
- 숫자 분석법
  - 레코드 키를 구성하는 수들이 모든 키들 내에서 자리별로 어떤 분포인지를 조사하여 비교적 고른 분포를 나타내는 자릿수를 필요한 만큼 선택하여, 레코드의 홈 주소로 사용하는 방법
```

### 5. 해싱 함수(Hashing Function)의 종류

- 해싱 함수 (산곱숫 폴기무)
  - 제산법
  - 제곱법
  - 숫자 분석법
  - 폴딩법
  - 기수 변환법
  - 무작위 방법

### 6. 이진 검색 알고리즘에 대한 설명

- 이진 검색 알고리즘에 대한 설명
  - 탐색 효율이 좋고 탐색 시간이 적게 소요된다.
  - 검색할 데이터가 정렬되어 있어야 한다.
  - 비교 횟수를 거듭할 때마다 검색 대상이 되는 데이터의 수가 절반으로 줄어든다.
- 피보나치 수열에 따라 다음에 비교할 대상을 선정하여 검색한다. (x)

### 9. 다음 자료를 버블 정렬을 이용한 오름 차순 정렬 결과는?

- 다음 자료를 버블 정렬을 이용하여 오름차순으로 정렬할 경우 PASS 2의 수행 결과는?
- 9, 6, 7, 3, 5
  - `6, 3, 5, 7, 9`

```markdown
- 초깃값
  - 9, 6, 7, 3, 5
    - 첫 번째 값과 두 번째 값을 비교하여 큰 값을 뒤로 이동
- PASS 1
  - 6, 9, 7, 3, 5
    - 두 번째 값과 세 번째 값을 비교하여 큰 값을 뒤로 이동
  - 6, 7, 9, 3, 5
    - 세 번째 값과 네 번째 값을 비교하여 큰 값을 뒤로 이동
  - 6, 7, 3, 9, 5
    - 네 번째 값과 다섯 번째 값을 비교하여 큰 값을 뒤로 이동
  - 6, 7, 3, 5, 9
    - 다시 첫 번째 값과 두 번째 값을 비교하여 큰 값을 뒤로 이동
- PASS 2
  - 6, 7, 3, 5, 9
    - 두 번째 값과 세 번째 값을 비교하여 큰 값을 뒤로 이동
  - 6, 3, 7, 5, 9
    - 세 번째 값과 네 번째 값을 비교하여 큰 값을 뒤로 이동
  - 6, 3, 5, 7, 9
    - 마지막 값(다섯 번째 값)은 PASS1 때 가장 큰 값이므로 PASS2 종료
  ```

### 10. 다음 자료의 삽입 정렬 기법에 대한 오름 차순 정렬 결과는?

- 다음 자료에 대하여 삽입 정렬 기법을 사용하여 오름 차순으로 정렬하고자 한다. 1회전 후의 결과는?
- 5, 4, 3, 2, 1
  - `4, 5, 3, 2, 1`
  - 삽입 정렬은 이미 정렬된 부분과 비교하여, 자신의 위치를 찾아 삽입하는 알고리즘이다.

```markdown
- 초깃값
  - 5, 4, 3, 2, 1
    - 맨 앞의 값인 5는 정렬되어 있다고 가정
- 1회전
  - 4, 5, 3, 2, 1
    - 초깃값에서 두 번째 값인 4는 5보다 작으므로 5 앞으로 이동
- 2회전
  - 3, 4, 5, 2, 1
    - 1회전 때 세 번째 값인 3은 4보다 작으므로 4 앞으로 이동
- 3회전
  - 2, 3, 4, 5, 1
    - 2회전 때 네 번째 값인 2는 3보다 크므로 3 앞으로 이동
- 4회전
  - 1, 2, 3, 4, 5
    - 3회전 때 다섯 번째 값인 1은 2보다 작으므로 2 앞으로 이동
```

### 12. 다음 자료의 선택 정렬을 이용한 오름차순 정렬의 3회전 후 결과는?

- 다음 자료에 대하여 선택(Selection) 정렬을 이용하여 오름차순으로 정렬하고자 한다. 3회전 후의 결과로 옳은 것은?
- 37, 14, 17, 40, 35
  - `14, 17, 35, 40, 37`
  - 정렬 되지 않은 데이터들에 대해 가장 작은 데이터를 찾아 정렬되지 않은 부분의 가장 앞의 데이터와 교환해나가는 알고리즘이다.

```markdown
- 초깃값
  - 37, 14, 17, 40, 35
    - 첫 번째 값인 37과 가장 작은 값인 14와 자리를 바꿈
- 1회전
  - 14, 37, 17, 40, 35
    - 두 번째 값인 37과 두 번째로 작은 값인 17과 자리를 바꿈
- 2회전
  - 14, 17, 37, 40, 35
    - 세 번째 값인 37과 세 번째로 작은 값인 35와 자리를 바꿈
- 3회전
  - 14, 17, 35, 40, 37
```

### 14. 클린 코드 작성 원칙

- 클린 코드 작성 원칙
  - 누구든지 쉽게 이해하는 코드로 작성
  - 중복성을 제거
  - 다른 모듈에 미치는 영향 최소화
  - 단순 및 명료한 코드로 작성

### 15. 알고리즘 설계 기법

- 알고리즘 설계 기법 (분동탐백)
  - 분할과 정복(Divide and Conquer)
  - 동적 계획법(Dynamic Programming)
  - 탐욕법(Greedy)
  - 백트래킹(Backtracking)

### 16. 소스 코드 품질분석 도구 중 정적분석 도구

- 소스 코드 품질분석 도구 중 정적분석 도구
  - pmd
  - checkstyle
  - cppcheck
- 정적분석 도구는 소스 코드의 잠재적인 문제를 발견한다.

### 17. 다음 설명의 클린 코드 작성 원칙은?

- 한 번에 한 가지 처리만 수행한다.
- 클래스/메서드/함수를 최소 단위로 분리한다.
  - `단순성`

### 22. 이진 검색 방법의 비교되는 횟수는?

- 다음과 같이 레코드가 구성되어 있을 때, 이진 검색 방법으로 14를 찾을 경우 비교되는 횟수는?
- 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
  - `3`

```markdown
- 1번째
  - 데이터의 개수는 15개이므로 가운데 레코드 번호는 (1+15)/2 = 8이다.
- 2번째
  - 14는 8보다 크므로 9부터 15 사이의 값이 되며, 가운데 레코드 번호는 (9+15)/2=12이다.
- 3번째
  - 14는 12보다 크므로 13과 15사이의 값이 되며, 가운제 레코드 번호는 (13+15)/2=14이다. (14를 찾았으므로 이진 검색 종료)
```
