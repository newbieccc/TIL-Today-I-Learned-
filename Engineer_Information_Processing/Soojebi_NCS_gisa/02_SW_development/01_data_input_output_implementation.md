# 정보처리기사 2024

## # 2-1. 소프트웨어 개발 - 데이터 입출력 구현

### # 1. 논리 데이터 저장소 확인 2-17page

### 1. 스택에 입력한 후 출력한 결과

- 순서가 A, B, C, D로 정해진 입력 자료를 스택에 입력한 후 출력한 결과로 가능한 것은?
  - `C, D, B, A`
- A, D, B, C (x)
  - A -> D -> C -> B (o)
- B, D, A, C (X)
  - B -> D -> C -> A (o)
- D, C, A, B (x)
  - D -> C -> B -> A (o)

### 2. 다음 중 선형 구조로만 묶인 것은?

- `큐, 데크`
- 선형 구조
  - 리스트
  - 스택
  - 큐
  - 데크
- 비선형 구조
  - 트리
  - 그래프

### 3. 다음에 해당하는 비선형 구조는?

- 긓래프의 특수한 형태로 노드(Node)와 선분(Branch)으로 되어 있고, 정점 사이에 사이클(Cycle)이 형성되어 있지 않으며, 자료 사이의 관계성이 계층 형식으로 나타나는 비선형 구조는?
  - `트리(tree)`

```markdown
- 비선형 구조는 트리, 그래프이다.
- 트리는 데이터들을 계층화시킨 비선형 자료 구조이다.
- 그래프는 노드(N; Node)와 노드를 연결하는 간선(E; Edge)을 하나로 모아놓은 비선형 자료 구조이다.
```

### 7. 다음은 스택의 자료 삭제 알고리즘이다. a에 들어갈 내용으로 옳은 것은? (단, Top: 스택 포인터, S: 스택의 이름)

```stack
If Top = 0 Then
    ( a )
Else {
    remove S(Top)
    Top = Top - 1
}
```

- `Underflow`

```stack
If Top = n Then
    Overflow
Else {
    Top = Top + 1
    insert S(Top)
}
```

- 삽입
  - 스택에 데이터가 n개이면
  - 삽입할 공간이 없으므로 오버플로
  - 스택에 데이터가 n개가 아니면
  - 스택 포인터 Top 값을 1 증가
  - 스택 포인터 Top가 가리키는 곳에 데이터 삽입

```stack
If Top = 0 Then
    Underflow
Else {
    remove S(Top)
    Top = Top - 1
}
```

- 삭제
  - 스택에 데이터가 0개이면
  - 삭제할 데이터가 없으므로 언더플로
  - 스택에 데이터가 0개가 아니면
  - 스택포인터 Top가 가리키는 곳에 데이터 삭제
  - 스택 포인터 Top 값을 1감소

### 9. 트리의 차수

- 해당 트리의 최대 차수는 `2개`
- 차수란 특정 노드에 연결된 자식 노드의 수이다.
  - A 차수 : B/C(2개)
  - B 차수 : D(1개)
  - C 차수 : E/F(2개)
  - E 차수 : G/H(2개)

### 10. 최대 간선 수

- 정점이 5개인 방향 그래프가 가질 수 있는 최대 간선 수는? (단, 자기 간선과 중복 간선은 배제한다.)
  - `20개`

```markdown
- m : 간선의 개수, n : 노드의 개수(정점의 개수)
- 방향 그래프 : m = n(n-1) = 5(5-1) = 20개이다.
```

### 11. 중위 순회(In-Order Traversal)

- `D B A E C F`
- 중위 순회 : Left -> Root -> Right
- B' -> A -> C'
- ( D -> B ) -> ( A ) -> ( E -> C -> F )

### 12. n개의 노드로 구성된 무방향 그래프의 최대 간선 수

- n개의 노드로 구성된 무방향 그래프의 최대 간선 수
  - `n(n-1)/2`
  - n개의 노드로 구성되어 있는 곳에 무방향 그래프를 그리면 n(n-1)/2이 된다.

### 13. 트리의 차수

- `3`
- 최대 차수인 B의 차수는 D, E, F로 3이다.

### 23. Tree 구조에 대하여 후위 순회(Post_order)

- `D -> B -> G -> H -> E -> F -> C -> A`
- 후위 순회 Left -> Right -> Root
- (B') -> (C') -> A
- (D -> B) -> (E' -> F -> C) -> A
- (D -> B) -> ((G -> H -> E) -> F -> C) -> A
- D -> B -> G -> H -> E -> F -> C -> A
