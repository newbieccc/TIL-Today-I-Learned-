# # 컴퓨터 구조

## 03. 컴퓨터 명령어 (2)

- 컴퓨터과학과 강지훈 교수님

### (1) 컴퓨터 명령어 개요

- 컴퓨터 명령어
    - 입력(2진 신호) -> 디지털 논리회로 -> 출력(2진 신호)
    - 입력(컴퓨터 명령어) -> 컴퓨터 시스템 -> 출력(명령어 수행 결과)
- 컴퓨터 명령어 (instruction)
    - 컴퓨터가 수행할 수 있는 작업을 표현하기 위한 비트들의 집합
    - 구조화된 형식을 가짐
- 명령어 집합(instruction set)
    - 컴퓨터에서 사용할 수 있는 명령어의 집합
    - ISA(Instruction Set Architecture)마다 고유한 명령어 집합을 가짐
    - 명령어 집합은 컴퓨터의 구조적인 특성을 나타내는 중요한 정보임

### (2) 컴퓨터 명령어의 구성

- 연산코드와 오퍼랜드
    - 명령어는 여러 개의 비트로 구성되며, 이 비트들은 연산코드와 오퍼랜드 정보를 담고 있음
    - 이러한 구성 요소를 구분하기 위해 여러 개의 필드로 정보를 구분함
        - 연산코드 필드: 처리해야 할 연산의 종류(연산자)
        - 오퍼랜드 필드: 처리할 대상 데이터 또는 데이터의 주소(피연산자)
- 컴퓨터 명령어의 수행 기능
    - 함수연산 기능
        - 산술, 논리연산 수행 기능
    - 정보전달 기능
        - 레지스터 사이, 중앙처리장치와 주기억장치 사이의 정보 전달 기능
    - 순서제어 기능
        - 조건 및 무조건 분기를 통한 명령어의 수행 순서 제어 기능
    - 입출력 기능
        - 주기억장치와 입출력장치 사이의 정보 이동 기능

### (3) 명령어 형식

- 명령어 형식
    - 명령어를 구성하는 필드의 수, 배치 방식 및 각 필드의 비트 수와 같은 명령어의 구조적 배치 방식
    - 명령어는 컴퓨터의 내부구조, 명령어 집합 구조에 따라 여러 가지 형식이 있음
- 명령어 형식의 분류
    - 오퍼랜드의 기억장소에 따른 명령어 형식
        - 누산기(AC: Accumulator)
            - 누산기를 가진 컴퓨터 구조에서 중앙처리장치에 존재하는 데이터 레지스터
            - 명령어가 수행될 때 오퍼랜드를 기억시키는 레지스터
        - 다중 레지스터
            - 중앙처리장치 내에 여러 개의 레지스터를 가지고 있는 컴퓨터 구조에서 사용되는 형식
        - 스택 구조
            - 스택 구조 컴퓨터는 연산에 필요한 오퍼랜드, 연산의 결과를 스택에 기억시키는 구조를 사용함
    - 오퍼랜드의 개수에 따른 명령어 형식
        - 3-주소 명령어
            - 명령어에 직접 명시된 오퍼랜드의 개수가 3개인 명령어 형식
            - 일반적으로 연산에 사용될 피연산자와 연산 결과를 저장할 목적지 모두를 명시함
        - 2-주소 명령어
            - 명령어에 직접 명시된 오퍼랜드가 2개인 명령어 형식
            - 일반적으로 연산에 사용될 피연산자 2개를 표현하며, 그 중 하나의 피연산자는 연산 결과가 저장될 목적지로 지정
            - 상업용 컴퓨터에서 가장 많이 사용
        - 1-주소 명령어
            - 명령어에 직접 명시된 오퍼랜드가 한 개인 명령어 형식
            - 기억장치로부터 오퍼랜드를 가져오거나, 연산 결과를 저장하기 위한 임시 저장소로 누산기를 사용
                - 명령어 실행 시 연산에 사용할 오퍼랜드 1개와 연산 결과를 저장할 위치가 이미 결정된 경우
        - 0-주소 명령어
            - 명령어에서 오퍼랜드를 명시적으로 표기하지 않음
            - 연산코드만 표현되고 오퍼랜드는 암시적으로 결정되어 있음
            - 스택 구조에서 사용되는 형식

### (4) 주소지정방식

- 명령어 주소지정방식(addressing mode)
    - 명령어가 오퍼랜드 필드의 비트를 해석해 연산 대상 값을 어떻게 찾을지 결정하는 방법
    - 오퍼랜드 필드의 비트 그룹을 어떻게 해석하여 연산에 사용할 실제 값에 접근할지를 정하는 규칙
    - 결국, 오퍼랜드가 저장된 실제 주소인 유효주소를 구하기 위해 오퍼랜드 필드를 해성하는 방식을 정의한 것이 주소지정방식임
- 주소지정방식 필드를 가징 명령어 형식
    - 연산코드 필드
        - 처리해야 할 연산의 정보
    - 주소지정방식 필드(addressing mode field)
        - 연산에 필요한 오퍼랜드의 주소를 알아내기 위한 정보 저장
    - 오퍼랜드 필드
        - 처리할 대상 데이터 또는 데이터의 주소 정보
- 주소지정방식 종류
    - 의미 주소지정방식
        - 명령어 형식에서 주소 필드를 사용하지 않는 방식
        - 명령어에서 사용할 오퍼랜드는 암시적으로 지정되어 있으며, 명령어에 직접 표시하지 않음
    - 즉치 주소지정방식
        - 명령어 자체 내에 오퍼랜드를 지정하고 있는 방식
        - 오퍼랜드 필드의 내용이 연산에 사용될 실제 데이터
        - 레지스터나 변수의 초기화에 유용
    - 직접 주소지정방식
        - 명령어의 주소필드에 오퍼랜드의 주소를 직접 저장하는 방식
    - 간접 주소지정방식
        - 명령어의 주소필드에 유효주소가 저장되어 있는 기억장치의 주소를 저장하는 방식
    - 레지스터 주소지정방식
        - 오퍼랜드 필드에 레지스터가 기억되는 방식
        - 오퍼랜드는 레지스터에 적재되어 있기 때문에 유효주소가 없음
    - 레지스터 간접 주소지정방식
        - 레지스터에 오퍼랜드의 유효주소가 들어있는 방식
    - 상대 주소지정방식
        - 특정 레지스터의 내용에 명령어의 오퍼랜드 필드 값을 더해서 유효 주소를 계산하는 방식
        - 특정 레지스터로 프로그램 카운터(PC)가 주로 사용됨
    - 인덱스 된 주소지정방식
        - 인덱스 레지스터의 내용을 명령어의 오퍼랜드 필드 값에 더해서 유효주소를 계산하는 방식

### (5) 명령어의 종류

- 데이터 전송
    - 데이터를 한 장소에서 다른 장소로 데이터를 전송하는 명령어
    - 레지스터와 레지스터 사이, 레지스터와 기억장치 사이, 기억장칭와 기억장치 사이에서 데이터를 이동하는 기능
    - 입출력 명령어도 이에 포함

| 전송명령어    | 니모닉  | 기능                                           |
|----------|------|----------------------------------------------|
| Load     | LD   | 기억장치로부터 레지스터로의 전송                            |
| Store    | ST   | 레지스터로부터 기억장치로의 전송                            |
| Move     | MOVE | 레지스터로부터 다른 레지스터로의 전송                         |
| Exchange | XCH  | 두 레지스터 간 또는 레지스터와 기억장치 간의 데이터 교환             |
| Push     | PUSH | 기억장치의 스택과 레지스터 간의 데이터 전송 *(일반적으로 레지스터 → 스택)* |
| Pop      | POP  | 기억장치의 스택과 레지스터 간의 데이터 전송 *(일반적으로 스택 → 레지스터)* |
| Input    | IN   | 레지스터와 입출력장치 간의 데이터 전송                        |
| Output   | OUT  | 레지스터와 입출력장치 간의 데이터 전송                        |

- 데이터 처리
    - 데이터에 대한 연산을 실행하며, 컴퓨터에 계산 기능을 제공
    - 데이터를 변경하는 모든 연산이 여기에 속함
        - 산술 명령어
        - 논리와 비트 처리 명령어
            - 레지스터나 기억장치에 저장된 단어(word)에 대한 2진 연산
            - 2진 부호화 정보를 표현하는 비트 그룹이나 개별 비트를 처리하는데 사용
            - 비트 값을 0으로 만들거나, 저장된 오퍼랜드에 새로운 비트 값을 삽입하는 작업 등을 수행
        - 시프트 명령어
            - 오퍼랜드의 비트를 왼쪽이나 오른쪽으로 이동시키는 명령어
            - 논리, 산술, 회전 시프트 연산 등이 있음

산술 명령어

| 산술 명령어               | 니모닉  | 기능         |
|----------------------|------|------------|
| Increment            | INC  | 1 증가       |
| Decrement            | DEC  | 1 감소       |
| Add                  | ADD  | 덧셈         |
| Subtract             | SUB  | 뺄셈         |
| Multiply             | MUL  | 곱셈         |
| Divide               | DIV  | 나눗셈        |
| Add with carry       | ADDC | 캐리를 포함한 덧셈 |
| Subtract with borrow | SUBB | 빌림을 포함한 뺄셈 |
| Negate               | NEG  | 2의 보수      |

논리와 비트 처리 명령어

| 논리 명령어           | 니모닉  | 기능            |
|------------------|------|---------------|
| Clear            | CLR  | 모든 비트를 0으로 리셋 |
| Set              | SET  | 모든 비트를 1로 셋   |
| Complement       | COM  | 모든 비트를 반전     |
| AND              | AND  | 비트별 AND 연산    |
| OR               | OR   | 비트별 OR 연산     |
| Exclusive-OR     | XOR  | 비트별 XOR 연산    |
| Clear carry      | CLRC | 캐리 비트의 리셋     |
| Set carry        | SETC | 캐리 비트의 셋      |
| Complement carry | COMC | (반전) 보수       |

시프트 명령어

| 시프트 명령어                 | 니모닉  | 기능                            |
|-------------------------|------|-------------------------------|
| Logical shift right     | SHR  | 오른쪽 시프트(왼쪽의 남는 비트는 0으로 채움)    |
| Logical shift left      | SHL  | 왼쪽 시프트(오른쪽의 남는 비트는 0으로 채움)    |
| Arithmetic shift right  | SHRA | 부호비트는 고정(왼쪽의 남는 비트는 부호비트로 채움) |
| Arithmetic shift left   | SHLA | 부호비트는 고정(오른쪽의 남는 비트는 0으로 채움)  |
| Rotate right            | ROR  | 오른쪽으로 순환(버려지는 비트는 다시 왼쪽비트로)   |
| Rotate left             | ROL  | 왼쪽으로 순환(버려지는 비트는 다시 오른쪽비트로)   |
| Rotate right with carry | RORC | 캐리를 포함한 오른쪽 순환                |
| Rotate left with carry  | ROLC | 캐리를 포함한 왼쪽 순환                 |

- 프로그램 제어
    - 프로그램 수행의 흐름을 제어
        - 프로그램 수행을 위한 명령어의 실행 순서를 제어
    - 다른 세그먼트로 분기

| 제어 명령어                   | 니모닉  | 기능                           |
|--------------------------|------|------------------------------|
| Branch                   | BR   | 조건 분기(조건에 따라 유효주소로 이동)       |
| Jump                     | JMP  | 무조건 분기(유효주소로 이동)             |
| Skip next instruction    | SKP  | 조건이 만족되면 다음 명령어를 수행하지 않고 넘어감 |
| Call procedure           | CALL | 서브루틴 호출                      |
| Return from procedure    | RET  | 서브루틴 실행 후 복귀                 |
| Compare (by subtraction) | CMP  | 두 오퍼랜드의 뺄셈을 통해 상태 레지스터 값 변화  |
| Test (by ANDing)         | TEST | 논리 AND 연산만 수행                |
