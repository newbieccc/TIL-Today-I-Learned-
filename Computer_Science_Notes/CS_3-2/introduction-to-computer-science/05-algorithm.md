# # 컴퓨터과학 개론

## 05. 알고리즘

- 컴퓨터과학과 이관용 교수님

### (1) 알고리즘의 개념

- 알고리즘
    - 주어진 문제도 단계적인 풀이 절차를 따르면 문제의 해를 구할 수 있음
- 알고리즘의 정의
    - 주어진 문제를 풀기 위한 명령어들을 단계적으로 나열한 것
        - 입출력: 0개 이상의 외부 입력, 1개 이상의 출력 생성
        - 명확성: 각 명령은 모호하지 않고 단순 명확해야 함
        - 유한성: 한정된 수의 단계를 거친 후에는 반드시 종료해야 함
        - 유효성: 모든 명령은 컴퓨터에서 실행할 수 있어야 함
        - 실용적 측면: **효율**적이어야 함
- 알고리즘 생성 단계
    - 설계
    - 표현/기술
    - 정확성 검증
    - 효율성 분석
- 자료구조와 알고리즘의 관계
    - 자료구조
        - 데이터 사이의 논리적 관계를 표현하고 조직화하는 방법
        - 기본적/대표적 종류: 배열, 연결 리스트, 스택, 큐, 트리, 그래프
    - 효율적 프로그램: 자료구조 + 알고리즘

### (2) 알고리즘의 설계

- 분할정복 방법
    - 순환적으로(recursively) 문제를 푸는 방법
        - 문제의 입력을 더 이상 나눌 수 없을 때까지
        - 2개 이상의 작은 문제로 순환적으로 분할하고
        - 분할된 문제들을 각각 해결한 후
        - 이들의 해를 결합하여 원래 문제의 해를 구하는 하향식 접근 방법
    - 특징
        - 분할된 작은 문제는 원래 문제와 동일, 단 입력 크기만 작아짐
        - 분할된 작은 문제는 서로 독립적
    - 각 순환 호출 시 다음 세 단계의 작업을 거침
        - 분할
            - 주어진 문제를 여러 개의 작은 문제로 분할
        - 정복
            - 작은 문제를 순환적으로 분할
            - 만약 작은 문제가 더 이상 분할되지 않은 정도로 크기가 충분히 작다면 순환호출 없이 작은 문제의 해를 구함
        - 결합
            - 작은 문제에 대해 정복된 해를 결합하여 원래 문제의 해를 구함
    - 퀵 정렬, 합병 정렬, 이진 탐색
- 동적 프로그래밍 방법
    - 최적화 문제의 해(최댓값, 최솟값)를 구하기 위한 상향식 접근 방법
        - 문제의 크기가 작은 소문제에 대한 해를 구해서 테이블에 저장해 놓고
        - 이를 이용하여 크기가 보다 큰 문제의 해를 점진적으로 만들어 가는 방식
        - 소문제들이 서로 독립일 필요 없음
        - 플로이드 알고리즘 (모든 정점 간의 최단 경로를 구하는 알고리즘)
- 욕심쟁이 방법
    - 해를 구하는 일련의 선택 과정마다 전후 단계의 선택과는 상관없이 각 단계에서 '가장 최선'이라고 여겨지는 국부적인 최적해를 선택해 나가면 결과적으로 전체적인 최적해를 얻을 수 있을 것이라고 희망하는 방법
    - 희망: 각 단계의 최적해를 통해 전체적인 최적해를 만들어 내지 못할 수 있음
        - 적용 범위가 제한적, 간단하면서 강력한 설계 기법
    - 거스름돈 문제, 배낭 문제

### (3) 알고리즘의 분석

- 알고리즘 분석
    - 정확성 분석
        - 유효한 입력과 유한 시간
            - 다양한 수학적 기법을 사용한 이론적 증명이 필요
    - 효율성 분석
        - 알고리즘 수행에 필요한 컴퓨터 자원의 양을 측정
        - 공간 복잡도(space complexity)
            - 메모리의 양 = 정적 공간 + 동적 공간
        - 시간 복잡도(time complexity)
            - 수행 시간
            - 알고리즘의 수행 시간
                - 컴퓨터에서 실행시켜 완료될 때까지 걸리는 실제 시간을 측정하는 방법
                - 알고리즘에서 수행되는 단위 연산의 수행 횟수를 모두 더한 값
                    - 입력으로 제공되는 데이터의 크기(입력 크기)가 증가하면 수행 시간도 증가
                        - 단순히 수행되는 단위 연산의 개수의 합이 아닌 입력 크기의 함수로 표현
                    - 입력 데이터의 상태에 따라 달라짐
                        - 평균 수행 시간, 최선 수행 시간, 최악 수핵 시간
    - 점근 성능
        - 입력 크기 n이 충분히 커짐에 따라 결정되는 성능

### (4) 정렬 알고리즘: 선택 정렬, 버블 정렬, 삽입 정렬

- 선택 정렬
    - 주어진 데이터 중에서 가장 작은 값부터 차례대로 선택해서 나열하는 방식
    - 최소값을 찾아 선택 후 맨 앞의 데이터와 위치를 바꿈 (왼쪽부터 데이터가 정렬 됨)
    - 성능: 언제나 동일한 수행 시간 O(n^2)
- 버블 정렬
    - 왼쪽에서부터 모든 인접한 두 데이터를 차례대로 비교하여 왼쪽의 값이 더 큰 경우에는 오른쪽 값과 자리를 바꾸는 과정을 반복
    - 오른쪽 값과 비교해서 큰 값을 맨 끝으로 이동시킴 (오른쪽부터 데이터가 정렬 됨)
    - 성능: 입력 데이터의 상태에 영향을 받음
        - 정렬이 되어 있는 경우 O(n)
        - 역순으로 정렬 되어 있다면 O(n^2)
    - 선택 정렬에 비해 데이터 교환이 더 많이 발생
        - 선택 정렬보다 비효율적
- 삽입 정렬
    - 주어진 데이터를 하나씩 뽑은 후, 나열된 데이터들이 항상 정렬된 형태를 가지도록 뽑은 데이터를 바른 위치에 삽입해서 나열하는 방식
        - 입력 배열을 정렬 부분과 미정렬 부분으로 구분하고
        - 미정렬 부분의 가장 왼쪽에 있는 데이터(첫 번째 데이터)를 뽑은 후 정렬된 부분에서 제자리를 찾아서 삽입하는 과정을 반복
    - 성능: 입력 데이터의 상태에 영향을 받음
        - 정렬이 되어 있는 경우 O(n)
        - 역순으로 정렬 되어 있다면 O(n^2)
