# # 컴퓨터과학 개론

## 12. 프로그래밍 언어(2)

- 컴퓨터과학과 정광식 교수님

### (1) 블록과 변수

- 블록과 변수의 유효 범위
    - 개요
        - 유효 범위(scope): 변수나 기타 식별자가 프로그램 코드의 어느 부분에서 보이고 사용할 수 있는지(존재 여부)를 결정하는 규칙
        - 유효 범위 결정 문제는 프로그램의 실행과 깊은 관련이 있음
        - 변수의 유효 범위 문제는 변수에 대한 기억 장소의 할당 및 유지(lifetime·storage)에 관한 문제임
    - 고급언어들 — 블록과 복합문
        - 대부분의 고급언어는 여러 명령문을 하나로 묶는 복합문과 여러 명령문이 모여 있는 블록(block) 을 제공한다.
        - 블록을 기준으로 변수의 유효 범위(scope) 가 결정된다.
    - 블록과 변수의 유효 범위
        - 블록은 중첩될 수 있어, 블록 안에 또 다른 블록이 올 수 있음.
        - 전역 변수 (global variable): 프로그램 코드의 모든 영역에서 유효하며, 프로그램 전반에 걸쳐 같은 기억 주소가 할당되어 사용됨.
        - 지역 변수 (local variable): 선언된 블록 내부에서만 유효하며, 블록을 벗어나면 접근할 수 없고 할당이 끝남(소멸).
        - 참고: 내부 블록의 동일한 이름의 변수는 외부 블록 변수와 이름이 가려질 수 있음(섀도잉).
    - 지역 변수의 할당과 소멸
        - 특정 블록에서 변수가 선언되면 그 블록에서 사용될 지역 변수에 대해 기억 장소(메모리) 할당이 이루어진다.
        - 블록 실행이 종료되면 해당 지역 변수는 소멸하고, 할당된 기억 장소가 반환/삭제된다.
    - 변수의 유효 범위 문제
        - 여러 단계로 중첩된 블록 사이에서, 특정 블록에 정의되지 않은 변수의 접근이 가능한지 유효성을 결정해야 하는 문제
        - 블록 사이에서의 변수 유효 범위를 결정하는 기준이 필요함
    - 유효 범위 규칙
        - 정적(lexical) 유효 범위
            - 변수의 유효 범위는 컴파일 시점에 결정됨
            - 소스 코드에서 가장 가까운(바깥으로 올라가며 처음 만나는) 선언이 적용됨
        - 동적(dynamic) 유효 범위
            - 변수의 유효 범위는 실행 시점의 호출 경로/환경에 따라 결정됨
            - 어떤 선언이 보이는지는 현재 호출 스택에 의해 달라짐
    - 유효 범위
        - 같은 이름의 변수가 프로그램의 여러 곳에서 정의·사용될 때, 어디서 정의된 어떤 변수의 값을 참조하고 접근할 것인지는 유효 범위(scope) 규칙에 따라 결정됨.

### (2) 함수의 기본 개념

- 부프로그램: 함수와 프로시저
    - 개요
        - 반복 사용되는 코드 부분을 하나의 단위로 묶고, 그 단위에 고유한 이름을 붙여 일반 명령처럼 호출해 쓰도록 만든 것을 부프로그램(subprogram) 이라 한다.
        - 부프로그램은 함수(function) 와 프로시저(procedure) 로 구분된다
            - 함수: 값을 반환한다.
            - 프로시저: 값을 반환하지 않거나 부수효과 중심이다.
        - 함수와 프로시저는 기능적으로 유사함
        - 함수(Function): 코드 실행의 결과값을 반환함 (return)
        - 프로시저(Procedure): 결과값을 반환하지 않음
        - C, C++ 등에서는 별도 구분 없이 모두 ‘함수’로 취급됨
    - 함수의 기본 요구조건
        - 제어 진입점은 한 곳으로 한정된다
        - 함수 호출이 발생하면, 호출한 프로그램의 수행이 일시 중단되고 실행 제어가 호출된 함수로 이전된다
        - 호출된 함수(피호출 함수)의 실행 중 종료 조건이 만족되면, 실행 제어가 호출자(함수/프로그램)로 돌아간다.
    - 함수의 호출
        - 함수의 제어 진입점은 항상 **한 곳(첫 줄)**이다.
        - 제어 종료(반환, return) 는 여러 조건에 따라 여러 지점에서 이루어질 수 있다.
- 함수의 매개변수
    - 매개변수
        - 호출 함수(호출자) 와 피호출 함수(피호출자) 는 서로 주고받을 정보가 필요하다.
        - 호출하는 프로그램은 피호출 함수가 처리할 대상 데이터를 알려줄 매개변수가 있어야 한다.
        - 매개변수(parameter): 호출하는 프로그램과 호출되는 함수 사이에서 주고받는 데이터
        - 메모: 호출 시 넘겨주는 실제 값은 보통 인자/인수(argument) 라고 부른다.
        - 함수를 호출할 때 함수 이름만 지정할 수도 있지만, 일반적으로는 피호출 함수에 여러 조건이나 데이터를 함께 전달하여 다양한 기능을 수행하도록 한다.
        - 이때 전달되는 값의 매개체가 매개변수(parameter) 이며, 매개변수는 특정 데이터형(type) 을 가진다.
    - 반환값
        - 피호출 함수의 실행 결과를 돌려주는 값이며, 반환값도 특정 데이터형을 가진다.
        - C 유사 의사코드의 기본 형태
        - 반환형과 return 값의 형이 일치해야 하며, 돌려줄 값이 없다면 void 반환형을 사용한다.

```C
int f(int x) {
    return x + 2;
}
```

- 매개변수 — 형식 vs 실매개변수
    - 형식매개변수(Formal parameter): 함수 정의에 쓰인 매개변수 이름
        - 예: int f(int **x**) { return x + 2; }의 x
    - 실매개변수(Actual parameter, argument): 함수 호출 시 전달하는 실제 값·식·변수
        - 예: f(**val**)의 val
    - C에서는 값 전달(call by value) 이 기본이라, 실매개변수의 값이 복사되어 형식매개변수로 전달된다.

```C
int f(int x) {        // x: 형식매개변수
    return x + 2;
}

int val;
int func_val;
val = 10;
func_val = f(val);    // val: 실매개변수(인수)
```

- 매개변수 — 예시
    - val → 실매개변수(인수)
    - x → 형식매개변수 (int f(int x)의 매개변수)
    - 호출 f(val) 시 값 전달(call by value) 로 val의 값 10이 x에 복사됨
    - 함수 계산: x + 2 = 12 → return 12
    - 대입: func_val 에 12 저장
    - 참고: 함수 내부에서 x를 바꿔도 원래의 val은 변하지 않음

```C
int f(int x) {
    return x + 2;
}

int val;
int func_val;

val = 10;
func_val = f(val);
```

- 호출 방식 — 값 호출 vs 참조 호출
    - 값 호출 (call by value)
        - 실매개변수의 값을 복사해서 형식매개변수로 전달
        - 함수 내부 변경이 호출자 변수에 영향 없음
    - 참조 호출 (call by reference)
        - 원본을 가리키는 참조/주소를 전달하여 함수 내부 변경이 호출자 변수에 반영
        - C에서는 포인터로 구현
    - 요약
        - 값 호출: 안전(부작용 적음) · 복사 비용 존재
        - 참조 호출: 원본 수정 가능(의도된 부작용) · 주의해서 사용
    - C는 기본이 값 호출이며, 참조 호출은 포인터로 흉내. C++은 int& 같은 참조로 직접 지원. Java는 값 호출이지만 객체는 참조 값을 복사해 전달.

```C
// 값 호출 예: a, b는 바뀌지 않음
void swap(int x, int y) {   // x, y는 복사본
    int tmp = x;
    x = y;
    y = tmp;
}
```

```C
// 참조 호출 예: a, b가 실제로 교환됨 (C 포인터 사용)
void swap(int *x, int *y) {
    int tmp = *x;
    *x = *y;
    *y = tmp;
}

// 사용
int a = 3, b = 5;
swap(&a, &b);   // a=5, b=3
```

- 값 호출 방식 — 개요
    - 값 호출(call by value): 실매개변수의 값을 복사해 형식매개변수로 전달한다.
        - 함수 내부에서 바뀐 값은 호출자 변수에 영향을 주지 않음.
    - 동작 요약
        - 호출 시 x=2, y=3으로 복사됨
        - 함수 내부에서 x↔y만 바뀜
        - 함수 종료 시 x, y는 소멸 → a, b는 그대로(2, 3)

```C
// 호출자
int a = 2;
int b = 3;
swap(a, b);
// a == 2, b == 3  (변화 없음)

// 피호출자
void swap(int x, int y) {  // x, y는 a, b의 '복사본'
    int tmp;
    tmp = x;
    x = y;
    y = tmp;
}
```

### (3) 변수의 수명

- 변수의 수명 — 개요
    - 정의: 변수가 값을 저장하기 위해 기억 장소를 할당받아 유지되는 시간.
    - 시작: 그 변수 이름으로 기억 장소가 할당되는 순간.
    - 끝: 할당된 기억 장소가 해제되는 순간.
    - 변수의 속성으로 자동 할당, 정적 할당, 프로그래머 지정 할당 등을 이용하여 기억 장소가 할당될 수 있음

- 자동 할당 방식
    - C 언어에서 주로 쓰는 변수 선언 방식(지역 변수의 기본, auto 생략됨)
    - 이 방식에서 변수의 수명 = 변수가 포함된 블록의 범위
    - 블록이 시작되면 변수에 메모리 할당, 블록이 끝나면 자동 회수됨(보통 스택에서 관리)

```C
void f() {
    int x = 0;      // 블록 시작 시 할당
    {
        int y = 1;  // 내부 블록에서만 존재
    }               // y 해제
}                   // x 해제
```

- 정적 할당 방식
    - 프로그램이 시작될 때, 기억 장소가 할당되며 블록이 끝나더라도 기억장소는 그대로 유지되고 프로그램 종료 시 회수됨
- 프로그래머 지정 할당 방식
    - 프로그램 실행 도중 프로그래머가 메모리 할당을 직접 요청해 받는다.
    - 메모리는 프로그래머가 직접 해제하여 운영체제에 반환할 때까지 유지된다.
    - 요청·해제 시점을 개발자가 책임하므로, 메모리 누수/이중 해제/댕글링 포인터에 주의해야 한다.

### (4) 객체 지향 프로그램을 위한 추상 자료형

- 추상화 — 개요
    - 프로그래밍에서 추상화는 대상의 필수적 속성만 남기고 부수적·불필요한 속성은 숨기거나 제거하여 모사하는 것.
    - 공통된 유사성을 드러내고 차이점은 감춘 채, 동일한 부류의 객체들을 하나의 개념으로 묶어 표현하는 방법.
- 프로시저의 추상화 — 개요
    - 프로시저 추상화: 어떻게 수행하는지(구현 과정)를 드러내지 않고, 무엇을 수행하는가만을 드러내도록 실행 과정을 모사·단순화하는 방법.
    - 예) sort_int(list, list_len)을 호출해 정수 배열을 정렬했다면, 호출문은 정렬 알고리즘의 구체 절차를 알 필요 없이 “정렬”이라는 작업 자체를 추상화해 수행한 것.
    - sort_int 프로시저의 필수 속성
- 자료의 캡슐화 — 개요
    - 자료 추상화/캡슐화는 프로그램의 재사용을 위해 도입된 개념으로, 여러 프로그래밍 언어에서 다양한 이름과 형태로 구현되어 있다.
    - 객체의 호출을 외부에 드러내는 부분을 공용부(public part) 또는 가시부(visible part) 라고 부른다.
    - 캡슐화로 보호되는 내부 구현 부분을 전용부(private part) 라고 부른다.
    - 요점: 외부에는 필요한 인터페이스만 공개하고, 구현 세부는 숨겨서 변경에 강하고 재사용 가능한 설계를 만든다.
