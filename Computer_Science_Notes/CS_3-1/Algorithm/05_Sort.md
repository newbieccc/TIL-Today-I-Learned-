# # 알고리즘

## 05. 정렬 (3)

- 컴퓨터과학과 이관용 교수님

### (1) 힙 정렬

- 힙 정렬
    - 힙 자료구조의 장점을 활용한 정렬
        - 임의의 값 삽입과 최댓값 삭제가 쉬움
    - (최대) 힙 heap
        - 완전 이진 트리
        - 각 노드의 값은 자신의 자식 노드의 값보다 크거나 같아야 함
    - 힙 정렬의 처리 과정
        - 1차원 배열을 힙으로 변환
            - 방법 1
                - 주어진 입력 배열의 각 원소를 힙에 삽입하는 과정을 반복
            - 방법 2
                - 주어진 입력 배열을 우선 완전 이진 트리로 만든 후, 각 노드에 대해 아래에서 위로 그리고 오른쪽에서 왼쪽으로 진행하면서 해당 노드의 아랫부분이 힙의 조건을 만족할 수 있도록 트리를
                  따라 내려가면서 자신의 자손 노드들과의 위치 교환을 계속해 나가는 방법
        - 최대값 삭제
        - 힙의 재구성
    - 성능과 특징
        - 최선, 최악, 평균 수행 시간
            - O(nlogn)
            - 초기 힙 생성, 최댓값 삭제 및 힙 재구성
                - 바깥 루프 -> 입력 크기 n에 비례
                - 안쪽 루프 -> 완전 이진 트리의 높이 logn에 비례
        - 안적정이지 않은 정렬 알고리즘
        - 제자리 정렬 알고리즘

### (2) 계수 정렬

- 계수 정렬
    - 비교 기반의 정렬 알고리즘
        - 기본 성능 O(n<sup>2</sup>) -> 선택 정렬, 버블 정렬, 삽입 정렬, 셸 정렬
        - 향상된 평균 성능 O(nlogn) -> 퀵 정렬, 합병 정렬, 힙 정렬
        - 비교 기반 정렬 알고리즘 성능의 하한 -> O(nlogn)
            - 아무리 빨라도 O(nlogn) 보다 효율적인 알고리즘은 구할 수 없음
    - 이미 얻어진 데이터 분포 정보를 활용하는 정렬 알고리즘
        - 계수 정렬, 기수 정렬, 버킷 정렬
            - 선형 시간 O(n)이 가능
    - 주어진 데이터 중에서 자신보다 작거나 같은 값을 갖는 데이터의 개수를 계산하여 정렬할 위치를 찾아 정렬하는 방식
        - 입력값이 어떤 작은 정수 범위 내에 있다는 것을 알고 있는 경우에 적용 가능
        - k보다 작거나 같은 값을 갖는 데이터의 개수
            - 정렬 순서상 k의 마지막 위치
        - 자신보다 작거나 같은 값을 같는 데이터의 개수의 효율적인 계산 방법
            - 입력값의 범위 a~b에 해당하는 크기의 배열 count[a..b]를 할당하고, 주어진 값들을 한 번 쭉 훑으면 각 입력값의 출현횟수의 누적값 계산이 가능
    - 성능과 특징
        - 입력값의 범위가 데이터의 개수보다 작거나 비례할 때 유용
            - 입력값의 범위를 k라고 할 때 O(n+k) 시간
                - k=O(n)이 되어야 선형 시간 O(n)에 동작
            - 안정적인 정렬 알고리즘
                - 입력 배열 A[]의 오른쪽의 것부터 뽑아서 결과 배열 B[]의 오른쪽에서부터 저장
            - 제자리 정렬 알고리즘이 아님
                - 입력 배열 A[1...n] + (COUNT[a..b], B[1...n])
            - 보편적이지 못한 정렬 알고리즘
                - 입력값의 범위를 미리 알아야 함 + 추가적인 배열이 필요

### (3) 기수 정렬

- 기수 정렬
    - 입력값을 자릿수별로 구분해서 부분적으로 비교하여 정렬하는 방식
        - 주어진 데이터의 값을 자릿수별로 나누고, 각 자릿수에 대해 계수 정렬과 같은 안정적인 정렬 알고리즘을 적용하여 정렬
            - LSD 기수 정렬 (Least Significant Digit)
                - 낮은 자리부터 높은 자리로 진행, "Right-to-Left"
            - MSD 기수 정렬 (Most Significant Digit)
                - 높은 자리부터 낮은 자리로 진행 "Left-to-Right"
    - 성능과 특징
        - 입력 데이터의 자릿수가 상수일 때 유용
            - d자릿수 n개의 숫자들에 대해 계수 정렬을 적용하면 O(dn)
                - 여기서 d를 입력 크기 nrk 무관한 상수로 간주하면 O(n)
            - 안정적인 정렬 알고리즘
                - 각 자릿수별로 안정적인 정렬 알고리즘을 적용하므로 기수 정렬도 안정적
            - 제자리 정렬 알고리즘이 아님
                - 계수 정렬 적용 -> 전체 데이터 개수와 진법 크기만큼의 추가 공간이 필요

### (4) 버킷 정렬

- 버킷 정렬
    - 과정
        - 주어진 데이터들의 값의 범위를 균등하게 나누어 여러 개의 버킷을 만든 뒤
        - 각 데이터를 해당하는 버킷에 넣고
        - 각 버킷을 삽입 정렬과 같은 안정적인 정렬을 수행한 후
        - 버킷 순서대로 각 데이터를 나열하는 정렬 방식
            - 입력값의 범위 내에서 값이 확률적으로 균등하게 분포될 때 선형 시간에 동작
    - 성능과 특징
        - 입력 데이터의 값이 확률적으로 균등하게 분포할 때 유용
            - 버킷별 정렬 -> 데이터들이 각 버킷에 균등하게 들어갈 때 효율적인 정렬이 가능
        - 버킷의 개수가 입력 데이터의 개수에 비례해야 유용
            - 버킷의 개수를 [n/k]개로 정하면 각 버킷에는 상수(k) 개의 데이터가 존재
                - 각 버킷을 상수 시간에 정렬 가능 -> 선형 시간의 동작이 가능
        - 안정적인 정렬 알고리즘
            - 데이터를 버킷에 넣을 때 그리고 각 버킷의 정렬 과정에서 상대적인 순서를 유지
        - 제자리 정렬 알고리즘이 아님
            - 추가적인 저장 공간(BUCKET[]과 크기 n의 배열 B[])이 필요
