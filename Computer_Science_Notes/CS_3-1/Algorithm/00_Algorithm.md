# # 알고리즘

## 00. 알고리즘 출석수업

- 컴퓨터과학과 이관용 교수님

### # 과제물

- 1번 문제
    - 주요 성능 관점 차례대로 좋은 순서로 나열
        - O(1)
        - O(logn)
        - O(n)
        - O(nlogn)
        - O(n<sup>2</sup>)
        - O(n<sup>3</sup>)
        - O(2<sup>n</sup>)
- 2번 문제
    - 기본 점화식과 폐쇄형
        - 2, 3, 6번 파랑색 인지
        - 2 -> 퀵 정렬(최악의 경우)
        - 3 -> 이진 탐색
        - 6 -> 합병 정렬, 퀵 정렬 (최선의 경우)
- 3번 문제
    - 3가지 알고리즘
    - 강의와 책에 있음
        - 욕심쟁이 방법 (greedy)
        - 분할정복 방법 (divide-and-conquer)
        - 동적 프로그래밍 방법 (dynamic programming)
- 4번 문제 (풀이과정 필수)
    - 배낭 문제 (욕심쟁이)
        - 쪼갤 수 있을 경우
        - 쪼갤 수 없는 경우
- 5번 문제
    - '선택 정렬의 예'처럼 그림을 그려준다
- 6번 문제
    - 퀵 정렬 그림을 그려 작성
        - A[0] 을 피벗으로 선언
            - LEFT, RIGHT 숫자 증가하면서 숫자 찾기
                - LEFT부터 큰 숫자를 찾기
                - RIGHT부터 작은 숫자를 찾기
                - 다음 순차에 큰, 작은 숫자를 교환
                - LEFT < RIGHT에서 LEFT > RIGHT 숫자가 될 때까지 진행
                - LEFT > RIGHT에서 피벗의 값과 마지막 RIGHT에 해당하는 숫자를 바꿈

### # (01_3) 알고리즘 설계

- 욕심쟁이 방법
    - 1장 : 거스름돈 문제, 배낭 문제
        - 배낭문제
            - 물체를 쪼갠다면 최대 가능
            - "0/1 배낭 문제"
                - 쪼갤 수 없다면...
                - "0/1 배낭 문제는 욕심쟁이 방법으로 해결 불가"
    - 4장 : 그래프
        - 최소 신장 트리 : 크루스칼 알고리즘, 프림 알고리즘
        - 단일 출발점 최단 경로 : 데이크스트라 알고리즘
- 분할정복 방법
    - 순환적으로 문제를 푸는 하향식 접근 방법 (top_down)
    - 대표적인 적용 문제
        - 퀵 정렬
        - 합병 정렬
        - 이진 탐색
            - 순서대로 나열되어 있어야 함
- 동적 프로그래밍 방법
    - 가장 작은 부분 문제부터 해를 구하여 테이블에 저장해 놓고, 큰 문제의 해를 점진적으로 만들어 가는 상향식 방법 (bottom_up)
    - 대표적인 적용 문제
        - 모든 정점 쌍 간의 최단 경로 ; 플로이드 알고리즘
        - 5장 : 행렬의 연쇄적 곱셈 문제, 최장 공통 부분 수열 문제

### # (02_1) 알고리즘 분석

- 정확성 분석
    - 유효한 입력에 대해 유한 시간 내에 정확한 결과의 생성 여부
        - 수학적 기법을 사용한 이론적인 증명 과정
- 효율성 분석
    - 알고리즘 수행에 필요한 컴퓨터 자원이 양을 측정/평가
    - 공간 복잡도 space complexity
        - 메모리의 양 = 정적 공간 + 동적 공간
    - 시간 복잡도 time complexity
        - 수행시간 = 알고리즘의 실행에서부터 완료까지 걸리는 시간
    - 알고리즘 수행시간 = {각 문장(연산)}이 수행되는 횟수}
        - 수행시간에 영향을 미치는 요인
            - 입력 크기
                - "입력되는 데이터의 크기", "문제가 해결하려는 대상이 되는 개체의 개수"
                    - 예 : 리스트 원소의 개수, 행렬의 크기, 그래프의 정점의 수 등
            - 입력 데이터의 상태
    - 입력 크기 n이 커질수록 수행시간도 증가
        - 단순히 단위 연산이 수행되는 개수의 합으로 표현하는 것은 부적절
            - 입력 크기 n의 함수 f(n)으로 표현
    - 입력 데이터의 상태에 종속적
        - 평균 수행시간
        - 최선 수행시간
        - 최악 수행시간

### # (02_2) 점근성능

- 입력 크기 n이 무한히 커짐에 따라 결정되는 성능
- 점근성능의 결정 방법
    - 입력 크기가 충분히 커짐에 따라 함숫값에 가장 큰 영향을 미치는 차수를 찾음
    - 수행시간의 다항식 함수에서 최고차항만을 계수 없이 취해서 표현
- 주요 성능 관점 차례대로 좋은 순서로 나열
    - O(1)
    - O(logn)
    - O(n)
    - O(nlogn)
    - O(n<sup>2</sup>)
    - O(n<sup>3</sup>)
    - O(2<sup>n</sup>)

### # (03_2) 선택 정렬

- 입력 배열에서 가장 작은 값부터 순서대로 '선택'해서 나열하는 방식
    - 가장 작은 숫자를 찾고 i 위치의 값과 바꾼다.
        - ex) 10개의 값 중에서 9(10-1)개를 비교한다.

### # (03_3) 버블 정렬

- 모든 인접한 두 데이터를 차례대로 비교하여 왼쪽 데이터가 더 큰 경우에는 오른쪽 데이터와 자리를 바꾸는 과정을 반복해서 정렬을 수행하는 방식
    - 비교를 진행하는 방향
        - 왼쪽에서 오른쪽으로 진행
            - 가장 큰 값부터 찾아서 오른쪽 끝에서부터 위치시킴
        - 오른쪽에서 왼쪽으로 진행
            - 가장 작은 값부터 찾아서 왼쪽 끝에서부터 위치시킴

### # (03_4) 삽입 정렬

- 미정렬 된 첫번째 데이터를 정렬 된 데이터에 알맞는 위치를 찾아 삽입
- 주어진 데이터를 하나씩 뽑은 후 이미 나열된 데이터가 항상 정렬된 상태를 유지하도록 뽑은 데이터를 바른 위치에 삽입해서 나열하는 방식
- 입력 배열을 정렬 부분 A[0...k-1]과 미정렬 부분 A[k..n-1]으로 구분해서 처리
    - A[0]를 정렬 부분, A[1..n-1]은 미정렬 부분으로 취급하여 시작
    - k=1, ..., n-1까지 반복
        - 미정렬 부분 A[k..n-1]의 첫 번째 데이터 A[k]를 뽑고,
        - A[0..k]가 정렬 상태를 유지하도록 만듦

### # (04_1) 퀵 정렬

- 계속 분할하여 교환 작업
- A[0] 을 피벗으로 선언
    - LEFT, RIGHT 숫자 증가하면서 숫자 찾기
        - LEFT부터 큰 숫자를 찾기
        - RIGHT부터 작은 숫자를 찾기
        - 다음 순차에 큰, 작은 숫자를 교환
        - LEFT < RIGHT에서 LEFT > RIGHT 숫자가 될 때까지 진행
        - LEFT > RIGHT에서 피벗의 값과 마지막 RIGHT에 해당하는 숫자를 바꿈
