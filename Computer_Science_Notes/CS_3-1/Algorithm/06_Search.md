# # 알고리즘

## 06. 탐색 (1)

- 컴퓨터과학과 이관용 교수님

### (1) 순차 탐색

- 탐색
    - 여러 개의 원소로 구성된 데이터에서 원하는 값을 갖는 원소를 찾는 것
        - 데이터의 형태 -> 리스트, 트리 그래프 등
        - 내부 탐색 vs 외부 탐색
        - 관련 연산 -> 탐색 + (초기화, 삽입, 삭제)
- 탐색 방법
    - 리스트 형태 -> 순차 탐색, 이진 탐색
    - 트리 형태 -> 이진 탐색 트리, 2-3-4 트리, 레드-블랙 트리, B-트리
    - 해시 테이블 -> 해시 함수, 충돌 해결 방법
- 탐색, 삭제 연산의 시간 복잡도 -> O(n)
    - 탐색 성공 -> 1번 ~ n번 비교 (평균 (n+1)2번), 탐색 실패 -> 항상 n번 비교
    - 삭제 -> 삭제할 원소의 순차 탐색 O(n) 후, 마지막 원소의 이동 O(1)
- 삽입 연산의 시간 복잡도 -> O(1)
    - 리스트의 마지막에 추가하는 데 상수 시간만 필요
- 정렬되지 않고 크기가 작은 데이터에 적합
    - 모든 리스트 형태의 입력에 적용 가능 -> 비정렬 데이터 탐색에 적합
    - 탐색과 삭제에 O(n) 시간이 필요 -> 데이터가 큰 경우에는 부적합

### (2) 이진 탐색

- 정렬된 리스트 형태로 주어진 원소들을 절만씩 줄여 가면서 원하는 값을 가진 원소를 찾는 방법
    - 분할정복 방법이 적용됨
- 탐색 방법
    - 배열의 가운데 원소 A[mid]와 탐색 키 key를 비교
        - (1) A[mid] = key -> 탐색 성공(인덱스 mid 반환 후 종료)
        - (2) key < A[mid] -> '이진 탐색(원래 크기의 1/2인 왼쪽 부분 배열)' 순환 호출
        - (3) A[mid] < key -> '이진 탐색(원래 크기의 1/2인 오른쪽 부분 배열)' 순환 호출
    - 탐색을 반복할 때마다 대상 원소의 개수가 1/2씩 감소
    - 주어진 배열이 정렬되어 있지 않으면 정렬 수행
- 연결 리스트 구조에서는 이진 탐색 자체가 불가능
- 성능과 특징
    - 성능
        - 탐색 연산 -> O(logn)
        - 초기화 연산 -> O(nlogn)
        - 삽입/삭제 연산 -> O(n)
    - 정렬된 리스트에 대해서만 적용 가능
    - 삽입과 삭제가 빈번한 경우에는 부적합
        - 연산 후 리스트의 정렬 상태를 유지하기 위해서 O(n)의 데이터 이동이 필요
            - 데이터가 작은 경우에 적합

### (3) 이진 탐색 트리

- 이진 트리
    - 한 노드의 왼쪽 서브트리에 있는 모든 키 값은 그 노드의 키값보다 작다.
    - 한 노드의 오른쪽 서브트리에 있는 모든 키 값은 그 노드의 키값보다 크다.
- 삽입 연산
    - 삽입할 원소를 탐색한 후, 탐색이 실패하면 해당 위치에 자식 노드로서 새 노드를 추가
- 삭제 연산
    - 후속자, 계승자 노드
        - 어떤 노드의 바로 다음 키값을 갖는 노드
    - 삭제되는 노드의 자식 노드의 개수에 따라 구분해서 처리
        - 자식 노드가 없는 경우(리프 노드의 경우)
            - 남는 노드가 없어 위치 조절이 불필요
        - 자식 노드가 하나인 경우
            - 자식 노드를 삭제되는 노드의 위치로 올리면서 서브트리 전체도 따로 올림
        - 자식 노드가 2개인 경우
            - 삭제되는 노드의 후속자 노드를 삭제되는 노드의 위치로 올리고,
            - 후속자 노드를 삭제되는 노드로 취급하여 자식 노드의 개수에 따라 다시 처리
- 탐색, 삽입, 삭제 연산의 시간 복잡도
    - 키값을 비교하는 횟수에 비례 -> 이진 트리의 높이가 h라면 O(h)
    - 평균 수행시간 O(logn)
    - 최악 수행시간 O(n)
- 삽입/삭제 연산 시 기존 노드의 이동이 거의 발생하지 않음
    - 삽입 연산 -> 노드의 이동이 없음
    - 삭제 연산 -> 상수 번 이동(0, 1, 1 또는 2)
- 원소의 삽입/삭제에 따라 경사 트리 형태가 될 수 있음
    - 최악의 수행시간 O(n)을 가짐
        - 경사 트리가 만들어지지 않도록 트리의 균형을 유지해서 O(logn)을 보장
            - 균형 트리 탐색(탐색 트리의 좌우 서브트리가 같은 높이를 유지하는 자료구조)
                - 2-3-4 트리, 레드-블랙 트리, B-트리

### (4) 2-3-4 트리

- 다음 성질을 만족하는 균형 탐색 트리
    - 2-노드 -> 1개의 키와 2개의 자식을 갖는 노드
    - 3-노드 -> 2개의 키와 3개의 자식을 갖는 노드
    - 4-노드 -> 3개의 키와 4개의 자식을 갖는 노드
    - 각 노드의 한 키의 왼쪽 서브트리에 있는 모든 키값은 그 키값보다 작다.
    - 각 노드의 한 키의 오른쪽 서브트리에 있는 모든 키값은 그 키값보다 크다.
    - 모든 리프 노드의 레벨은 동일
- 탐색 과정에서 4-노드를 만나면 항상 노드 분할을 우선 수행
- 탐색, 삽입, 삭제 연산의 시간 복잡도 -> O(logn)
    - 균형 탐색 트리 -> 트리의 최대 높이 [logn]
- 삽입/삭제가 일어나도 경사 트리가 되지 않음
    - 루트 노드가 분할되는 경우에 한해서 모든 노드의 레벨이 동일하게 1씩 증가
- 2-3-4 트리를 그대로 구현하면 노드 구조가 복잡해서 이진 탐색 트리보다 더 느려집 가능성이 많음
