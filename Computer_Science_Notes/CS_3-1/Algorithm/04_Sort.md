# # 알고리즘

## 04. 정렬 (2)

- 컴퓨터과학과 이관용 교수님

### (1) 퀵 정렬

- 퀵 정렬
    - 특정 데이터를 기준으로 주어진 배열을 2개의 부분배열로 분할하고, 각 부분배열에 대해서 퀵 정렬을 순환적으로 적용하는 방식
    - 피벗 (pivot, 분할 원소)
        - 주어진 배열을 두 부분배열로 분할하는 기준이 되는 특정 데이터
        - 보통 주어진 배열의 첫 번째 데이터로 지정
    - 피벗이 제자리를 잡도록 하여 정렬하는 방식
    - 왼쪽 부분배열의 모든 값 < 피벗 < 오른쪽 부분배열의 모든 값

```java
QuickSort(A[], n) {
    if (n > 1) {
        // 1 피벗을 기준으로 두 부분배열로 분할
        //
        pivot = Partition(A[0...n - 1],n);

        // 2 왼쪽 부분 배열에 대한 퀵 정렬의 순환 호출
        QuickSort(A[0..pivot - 1], pivot);
        QuickSort(A[pivot + 1...n - 1],n - pivot - 1);
    }
}
```

```aiignore
int Partition (A[], n)
{
    Left = 1; Right = n-1;
    while (Left < Right) {
        while (Left < n && A[Left]) <A[0] Left++;       // 오른쪽으로 진행하면서 피벗 A[0]보다 큰 값의 위치를 찾음
        while (Right > 0 && A[Right] >= A[0]) Right--;  // 왼쪽으로 진행하면서 피벗 A[0]보다 작은 값의 위치를 찾음
        if (Left < Right) {
            A[Left]와 A[Right]의 위치 교환
        } else {
            피벗 A[0]와 A[Right]의 위치 교환
            // 피벗과의 위치 교환 후 첫번째 while문 종료
        }
    }
    return (Right)
}
```

- 퀵 정렬 QuickSort()의 수행시간은 분할되는 두 부분배열의 크기에 따라 달라짐
- 배열이 항상 0:n-1 또는 n-1:0으로 분할되는 경우
    - 극심한 불균형적 분할 -> 최악의 경우
        - 0:n-1, n-1:0 -> 피벗만 제자리를 잡고 나머지 모든 원소가 하나의 부분배열이 되는 경우
        - 피벗이 항상 부분배열의 최솟값 또는 최댓값이 되는 경우
        - 입력 데이터가 정렬된 경우 AND 피벗을 배열의 첫 번째 원소로 정한 경우
        - T(n) = O(n<sup>2</sup>)
- 배열이 항상 n/2:n/2로 분할되는 경우
    - 가장 균형적인 분할 -> 최선의 경우
        - 피벗을 중심으로 항상 동일한 크기의 두 부분배열로 분할되는 경우
        - 피벗이 항상 배열의 중간값이 되는 경우
        - T(n) = O(nlogn)
- 피벗 선택의 임의성만 보장되면 평균 수행시간을 보장
    - 최선/평균 수행시간 -> O(nlogn)
    - 최악의 수행시간 -> O(n<sup>2</sup>)
        - 피벗을 배열의 첫 번째 원소로 지정하는 경우 AND 배열이 정렬된 경우
        - 배열에서 임의의 값을 선택한 후, 배열의 첫 번째 원소와 서로 교환한 후 정렬 수행
- 제자리 정렬 알고리즘
    - 입력 배열 이외에 추가적인 저장 공간을 상수 개(Left, Right, tmp, n, pivot)만 사용
- 안정적이지 않은 정렬 알고리즘
- 분할정복 방법이 적용된 알고리즘
    - 분할
        - 피벗을 기준으로 주어진 배열을 두 부분배열로 분할 -> 두 부분배열의 크기는 일정하지 않음
    - 정복
        - 두 부분배열에 대해서 퀵 정렬을 순환적으로 적용하여 각 부분배열을 정렬함
    - 결합
        - 결합이 필요없음

### (2) 합병 정렬

- 합병 정렬
    - 주어진 배열을 동일한 크기의 두 부분배열로 분할하고,
    - 각 부분 배열에 순환적으로 합병 정렬을 적용하여 정렬시킨 후,
    - 정렬된 두 부분배열을 합병하여 하나의 정렬된 배열을 만듦

```aiignore
MergeSort(A[], n) {
    if (n > 1) {
        Mid = [n/2];
        B[0..Mid-1] = MergeSort(A[0..Mid-1]);
        // 왼쪽 부분배열의 순환 호출 -> 크기 n/2인 정렬된 배열 반환
        
        C[0..n-Mid-1] = MergeSort(A[Mid..n-1], n-Mid);
        // 오른쪽 부분배열의 순환 호출 -> 크기 n/2인 정렬된 배열 반환
        
        A[0..n-1] = Merge(B[0..Mid-1], C[0..n-Mid-1], Mid, n-Mid);
        // 정렬된 두 부분배열 B[]와 C[]의 합병 : A[] = B[] + C[]
    }
    return (A);
}


Merge (B[], C[], n, m) {
    i = j = k = 0;
    while (i < n && j < m) {
        if (B[i] <= C[j]) {
            A[k++] = B[i++]; 
        } else {
            A[k++] = C[j++];
        }
    }
    for (; i < n; i++) {
        A[k++] = B[i];
    }
    for (; j < m; j++) {
        A[k++] = C[j];
    }
    return (A[0..n+m-1]);
}
```

- 성능과 특징
    - 안정적인 정렬 알고리즘
        - 합병 과정에서 동일한 두 데이터에 대해서 항상 왼쪽 데이터를 먼저 선택함
    - 제자리 정렬 알고리즘이 아님
        - A[n] = B[n/2] + C[n/2] -> 입력 크기 n만큼의 추가적인 공간을 요구
    - 전형적인 분할정복 방법이 적용됨
        - 분할
            - 주어진 배열을 동일한 크기의 2개의 부분배열로 분할
        - 정복
            - 각 부분배열에 대해서 합병 정렬을 순환적으로 적용하여 정렬함
        - 결합
            - 정렬된 두 부분배열을 합병하여 하나의 정렬된 배열을 만듦
