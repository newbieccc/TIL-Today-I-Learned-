### (1) 레드-블랙 트리

- 이진 탐색 트리, 균형 탐색 트리
    - 성질 1
        - 모든 노드는 검정이거나 빨강이다.
    - 성질 2
        - 루트 노드와 리프 노드는 검정이다.
            - 모든 리프 노드는 NULL 노드이다.
    - 성질 3
        - 빨강 노드의 부모 노드는 항상 검정이다.
            - 빨강 노드가 연달아 나타날 수 없음
    - 성질 4
        - 임의의 노드로부터 리프 노드까지의 경로상에는 동일한 개수의 검정 노드가 존재한다.
    - 성질 5, 성질 6
        - 이진 탐색 트리의 성질
- 빨강 노드가 연달아 나타나는 경우에 적용하는 규칙
    - 규칙 1 -> 부모 노드가 형제 노드가 빨강인 경우
        - 부모 노드, 부모 노드의 형제 노드, 부모 노드의 부모 노드의 샐깔을 모두 변경
    - 규칙 2 -> 부모 노드의 형제 노드가 검정이고, 현재 노드의 키값이 부모 노드와 부모 노드의 부모 노드의 키값의 사이인 경우
        - 현재 노드와 부모 노드를 회전시킴
    - 규칙 -> 부모 노드의 형제 노드가 검정이고, 현재 노드의 키값보다 부모 노드와 부모 노드의 부모 노드의 키값이 큰(또는 작은) 경우
        - 부모 노드와 부모 노드의 부모 노드를 회전시키고 색깔을 변경

- 균형 탐색 트리
    - 어떤 두 리프 노드의 레벨 차이가 2배를 넘지 않는 균형 탐색 트리
        - 성질 3 -> 루트 노드에서 리프 노드의 경로상에는 '빨강 노드의 개수 < 검정 노드의 개수'
        - 성질 4 -> 루트 노드에서 리프 노드의 경로상에는 동일한 개수의 검정 노드가 존재
- 탐색, 삽입, 삭제 연산의 시간 복잡도 -> O(logn)
    - 최악의 경우 트리의 높이 O(logn)
- 사실상 이진 탐색 트리
    - 탐색 연산은 이진 탐색 트리와 동일
        - 삽입 연산은 회전과 색깔 변경과 같은 추가 연산이 필요

### (2) B-트리

- 균형 탐색 트리 (t는 자연수인 상수)
    - 성질 1 -> 루트 노드는 1개 이상 2t개 미만의 오름차순으로 정렬된 키를 가짐
    - 성질 2 -> 루트 노드가 아닌 모든 노드는 (t-1)개 이상 2t개 미만의 오름차순으로 정렬된 키를 가짐
    - 성질 3 -> 내부 노드는 자신이 가진 키의 개수보다 하나 더 많은 자식 노드를 가짐
    - 성질 4 -> 각 노드의 한 키의 왼쪽 서브트리에 있는 모든 키값은 그 키값보다 작음
    - 성질 5 -> 각 노드의 한 키의 오른쪽 서브트리에 있는 모든 키값은 그 키값보다 큼
    - 성질 6 -> 모든 리프 노드의 레벨은 동일함
- 루트 노드에서부터 탐색을 수행하여 리프 노드에서 존재하지 않으면 해당 노드에 추가
- 노드 분할
    - 탐색 과정에서 (2t-1)개의 키를 갖는 노드를 만나면, 이 노드를 (t-1)개의 키를 갖는 2개의 노드와 1개의 키를 갖는 노드로 분할
        - 삽입으로 인해 노드의 키의 개수가 2t개가 되는 것을 방지
- 성능과 특징
    - 탐색, 삽입, 삭제 연산의 시간 복잡도 -> O(logn)
        - 트리의 높이 h, 각 노드에서 키의 위치를 찾는 시간 O(t) -> O(th)
            - 각 노드 -> 키의 개수 : (t-1)~(2t-1)개, 자식 노드의 개수 : t~2t개
            - 모든 리프 노드의 레벨은 동일
            - 트리의 높이 h -> O(log<sub>t</sub>n) n:키의 개수)
            - 각 노드에서의 키 관리에 레드-블랙 트리를 이용하면 O(t) 시간 -> O(logt)
    - 내부 탐색과 외부 탐색에 모두 활용
        - 내부 탐색의 경우
            - t=2 또는 t=3 정도의 작은 값으로 지정
            - t=2 -> '2-3-4 트리'
        - 외부 탐색의 경우
            - 디스크를 사용하는 경우라면 t를 충분히 크게 지정
                - 한 노드의 크기가 디스크의 한 블록에 저장되도록 함

### (3) 해시 테이블

- 해싱
    - 키 값을 기반으로 데이터의 저장 위치를 직접 계산함으로써 상수 시간 내에 데이터를 저장, 삭제, 탐색할 수 있는 방법
- 해시 테이블
    - 각 위치마다 주소가 부여 되어 있는 저장공간
    - 배열 형태
- 해싱이 적합한 형태의 응용 문제는?
    - 특정 키값 K를 갖는 데이터를 찾는 문제
- 해시 함수
    - 키값을 해시 테이블의 주소로 변환하는 함수
    - 종류
        - 제산 잔여법, 비닝, 중간 제곱법, 문자열을 위한 함수(비닝, 단순 합, 가중 합) 등
    - 바람직한 해시 함수
        - 계산이 용이해야 함
        - 적은 충돌 발생 -> 각 키를 테이블의 각 슬롯에 균등하게 사상시킬 수 있어야 함
    - 제산 잔여법
        - h(K) = K mod M (K:키 값, M:해시 테이블의 크기)
            - h(123) = 123 mod 11 = 2
        - M의 선택에 주의해야 함
            - M = 2<sup>r</sup>이면 h(K)는 키값의 하위 r비트의 값이 됨
                - 키값의 전체 비트가 주소 계산에 활용되지 못함
    - 중간 제곱법
        - h(K) = (K<sup>2</sup> / 2<sup>m</sup>) mod 2<sup>r</sup>
            - (m: 키값을 제곱한 결과에서 사용하지 않을 하위 비트의 크기, r:해시 주소로 취할 비트의 크기)
        - (1) 주어진 키값을 제곱한다
        - (2) 제곱된 결과에서 하위 m를 버리고 M에 해당하는 하위 r비트를 취한다.
            - 모든/대부분의 비트가 결과 생성에 기여
                - 상위/하위 자리의 분포에 의해 지배적인 영향을 받지 않음
    - 문자열을 위한 비닝
        - U를 단순하게 M 등분하여 각 등분을 각 슬롯으로 해시
            - 문자열의 앞쪽 일부를 해시 결과로 사용
                - 입력 문자열의 앞쪽의 분포가 고르지 못하면 결과가 슬롯에 고르게 분포되지 못함
    - 문자열을 위한 단순 합
        - 각 문자의 코드값을 합한 후 제산 잔여법 적용
    - 문자열을 위한 가중 합
        - 각 문자의 코드값에 자리에 따른 가중치를 곱한 값을 합한 후 제산 잔여법을 적용
    - 충돌 해결 방법
        - 충돌
            - 서로 다른 키값 x, y에 대하여 h(x)=h(y)인 경우
        - 충돌 해결 방법
            - 개방 해싱 (연쇄법)
                - 충돌된 데이터를 테이블 밖의 별도의 장소에 저장/관리 -> 연결 리스트 사용
                - 해시 테이블의 각 슬롯을 연결 리스트의 헤더로 사용
                    - 해시 테이블과 연결 리스트가 주기억장치 내에서 유지될 때 적합
            - 폐쇄 해싱 (개방 주소법)
                - 해시 테이블 내의 다른 슬롯에 충돌된 데이터를 저장/관리
                - 종류
                    - 버킷 해싱
                        - 해시 테이블 슬롯을 버킷으로 묶어 버킷 단위로 해싱
                        - 디스크에 저장된 해시 테이블 구현에 적합
                        - 버킷 크기 = 디스크 크기, 오버플로는 작게 유지
                    - 선형 탐사
                        - 탐사 순서 probe sequence
                            - 어떤 키 K에 대해서 탐사되는 슬롯의 순서열
                            - 탐사 순서의 계산 방법에 따라 성능의 차이가 발생
                                - 선형 탐사, 이차 탐사, 이중 해싱
                        - 선형 탐사 linear probing
                            - 홈 위치가 사용 중이면 빈 슬롯을 찾을 때까지 테이블의 다음 슬롯으로 순차적으로 이동
                            - 모든 슬롯이 새로운 데이터가 삽입될 후보가 됨
                            - 1차 클러스터링 문제 -> 긴 탐사 순서를 만들어 평균 탐색 시간의 증가를 초래
                                - 데이터들이 연속된 위치를 점유하여 클러스터를 형성하고 이것이 점점 커지는 현상
                    - 이차 탐사
                        - 탐사 순선의 계산에 이차식을 이용
                            - 충돌이 발생하는 횟수의 제곱 형태로 탐사 순서를 결정
                        - 서로 다른 홈 위치를 갖는 두 키는 서로 다른 탐사 순서를 가짐
                        - 모든 슬롯이 탐사 순서에 사용되지 않음
                            - 탐사 함수와 해시 테이블 크기가 적절히 조합되면 많은 슬롯의 방문이 가능
                        - 2차 클러스터링 문제
                            - 동일한 홈 위치를 갖는 두 키는 동일한 탐사 순서를 가짐
                                - 특정 홈 위치에 대한 클러스터를 만드는 현상
                    - 이중 해싱
                        - 탐사 순서를 원래의 키값을 이용하여 해싱
                            - 1차/2차 클러스터링 문제 해결
                            - 서로 다른 두 키의 홈 위치가 동일해도 서로 다른 탐사 순서를 가짐
                        - 좋은 이중 해싱을 구하려면
                            - 탐사 순서에 있는 모든 상수가 해시 테이블의 크기 M과 서로 소가 되어야 함
    - 삭제 연산
        - 두 가지 고려 사항
            - 데이터의 삭제가 차후의 탐색을 방해하지 말아야 함
                - 단순히 빈 슬롯으로 두면 탐색이 해당 슬롯에서 종료되므로 그 이후의 데이터는 고립됨
            - 삭제로 생긴 빈 슬롯은 나중에 삽입 과정에서 사용되어야 함
        - 비석 tombstone
            - 삭제된 데이터의 위치에 '비석'이라는 특별한 표시를 하는 방법
                - 탐색 -> 탐색하는 동안 비석을 만나면 탐색을 계속 진행
                - 삽입 -> 비석이 표시된 위치를 빈 위치로 간주하여 새 데이터를 삽입
            - 비석의 개수가 증가할수록 평균 탐색 거리가 증가
