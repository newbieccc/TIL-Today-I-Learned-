### (1) 벨만-포드 알고리즘 (최단 경로)

- 벨만-포드 알고리즘
  - 단일 출발점 최단 경로를 구하는 알고리즘
    - 음의 가중치를 갖는 간선이 존재하는 경우에도 처리 가능
      - 음의 사이클이 없는 경우에 한함
    - G=(V, E)에서 |V|=n일 때 단계적으로 최단 경로를 구해 나가는 방법
  - 수행 과정
    - 초기화
      - 출발점 s의 거리 d[s]=0, 나머지 모든 정점 v의 거리 d[v]='무한대'
    - for i <- 1 to |V|-1
      - 모든 간선을 한 번씩 조사하면서 거리값 조정 여부를 결정
        - d[v] <- min{기존 거리, 간선 <u,v> 를 지나는 경우의 거리}
        - 전 단계에서 거리값 d[]의 조정이 발생한 정점에 부수된 간선만 조사
  - 성능과 특징
    - O(|V||E|)
    - 음의 가중치를 갖는 간선이 있는 경우
      - 데이크스트라 알고리즘 적용 불가
      - 벨만-포드 알고리즘 적용 가능
        - 단, 음의 사이클이 존재하면 적용 불가
      - 음의 가중치를 갖는 간선이 없는 경우
        - 데이크스트라 알고리즘 -> O((|V|+|E|)log|V|)
        - 벨만-포드 알고리즘 -> O(|V||E|)

### (2) 플로이드 알고리즘 (최단 경로)

- 플로이드 알고리즘
  - 모든 쌍 최단 경로 알고리즘
    - "Floyd-Warshall 알고리즘"
    - 가정 -> 경로의 길이가 음인 사이클이 존재하지 않음
    - 적용 기법 -> 동적 프로그래밍 방법
    - 경유할 수 있는 정점의 범위가 1인 경로부터 시작해서 |V|인 경로까지 하나씩 정점의 범위를 늘려 가면서 모든 정점 간의 최단 경로를 한꺼번에 구함
  - 성능과 특징 (n=|V|)
    - O(n<sup>2</sup>)
    - O(n<sup>3</sup>)
    - 동적 프로그래밍 방법을 적용한 알고리즘
    - 데이크스트라 알고리즘으로 모든 쌍 최단 경로를 구할 수 있음
      - 각 정점에 대해서 반복적으로 적용해서 해결 가능 -> O(|V|<sup>3</sup>)
      - 플로이드 알고리즘이 더 간단하므로 빠르게 수행
        - |E| << |V|<sup>2</sup>인 경우에는 데이크스트라 알고리즘의 반복 적용이 더 효과적
    - P[1..n][1..n] 2차원 배열을 활용하면 최단 경로 자체를 구할 수 있음

### (3) 포드-풀커슨 알고리즘 (네트워크 플로 문제)

- 네트워크 플로 문제
  - 주어진 네트워크에 대해서 플로를 최대로 하는 값을 찾는 문제
    - 소스에서 싱크로 보낸 수 있는 플로 값을 최대로 하는 문제 -> "최대 플로 문제"
  - 네트워크 N=(V,E,s,t,c)
    - 방향 그래프 G=(V,E)
    - s -> 소스 (시작점, 진입차수가 0인 정점)
    - t -> 싱크 (도착점, 진출차수가 0인 정점)
    - c -> 간선의 가중치 -> 간선의 용량
      - c(u, v) -> 간선 <u,v)를 통해 보낼 수 있는 최대의 양/값
