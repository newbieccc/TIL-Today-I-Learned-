# # 디지털 논리회로

## 09. 순서논리회로 (1)

- 컴퓨터과학과 강지훈 교수님

### (1) 순서논리회로 개요

- 순서논리회로의 분류
    - 동기 순서논리회로(Synchronous Sequential Logic)
        - 저장 요소로 플립플롭(flip-flop)을 일반적으로 사용함
        - 특정 순간에만 저장 요소의 내용을 변화시킬 수 있는 신호인 클럭 펄스를 사용
        - 클럭 펄스는 시스템 전체에 제공되며, 구성 요소들은 클럭 펄스를 기반으로 동작 타이밍을 결정
    - 비동기 순서논리회로(Asynchronous Sequential Logic)
        - 저장 요소로 시간지연 소자(time-delay device)를 사용할 수 있음
        - 시간지연소자로 인해 신호가 전달되려면 일정한 시간이 걸리며, 이를 통해 신호를 기억하는 것 처럼 동작하게 할 수 있음
            - 실제로 기억소자 역할을 완전히 대체하는 것은 아님
        - 구성 요소간 공유하는 기준 타이밍인 클럭이 없기 때문에 여러 신호가 거의 동시에 바뀔 경우, 회로가 예상치 못한 순서로 상태가 변화할 수 있음
    - 동기식
        - 서로 상호작용하는 구성 요소들이 같이 공유하는 신호에 맞춰 동작하는 방식
        - 공통된 클럭(Clock) 신호에 맞춰 동작 타이밍이 고정됨
        - 정해진 순서/시간에 맞게 동작함
    - 비동기식
        - 공통의 동작 신호 없이 입력 변화나 이벤트에 따라 즉시 반응
        - 구성요소들은 각자 자신의 타이밍에 따라 작동함
        - 타이밍 조율이 필요한 경우 신호, 핸드 셰이크(handshake) 등을 사용

- 동기, 비동기 순서논리회로의 비교

| 항목        | 동기 순서논리회로           | 비동기 순서논리회로               |
|-----------|---------------------|--------------------------|
| 동작 타이밍    | 클럭(Clock) 기반        | 이벤트와 같은 게이트간 피드백 기반      |
| 상태 변화 시점  | 클럭의 에지(상승/하강)에서만 변화 | 입력 변화가 발생하면 즉시 변화        |
| 기억소자      | 플립플롭                | 시간지연 소자, 래치              |
| 상태 기억 방법  | 클럭 기반의 안정적인 상태 저장   | 피드백과 지연을 통해 상태 유지 구조를 형성 |
| 성능        | 클럭 주기에 따라 제한적       | 클럭을 기다릴 필요 없기 때문에 빠름     |
| 안정성       | 높음                  | 낮을 수 있음(환경에 민감)          |
| 동작 타이밍 제어 | 클럭 기반으로 구성요소 전체 동기화 | 지연소자를 이용한 국소적 타이밍 조정     |

### (2) 플립플롭

- 플립플롭
    - 1비트의 2진 정보를 저장할 수 있는 기억소자
        - 1비트의 정보를 보관하고 유지할 수 있으며, 순서논리회로의 기본 요소 중 하나임
        - 플립플롭 여러 개를 연결해서 여러 개의 비트 정보를 저장할 수 있음
    - 입력 신호에 의해 상태 변경 지시가 있을 때 까지 현재의 2진 상태를 유지
    - 클럭 신호에 의해 출력 상태를 바꿈
- 플립플롭의 종류
    - RS, D, JK, T, 마스터-슬레이브 플립플롭(Flip Flop: F/F)
        - 클럭 신호에 의해 출력이 바뀜
        - 동기 순서논리 소자
    - SR 래치(Set-Reset latch)
        - 넓은 의미의 플립플롭 - "디지털 기반 기억소자" 전체를 일컫는 포괄적인 개념의 플립플롭
        - 구동 입력이 1일 때 출력이 바뀜
        - 비동기 순서논리 소자
        - 두 개의 NOT 게이트나 두 개의 NAND 게이트를 사용한 교차 피드백 구조로 구성
        - 각각 세트(set)와 리셋(reset) 두 입력을 가짐

- NOR 게이트로 된 래치
    - SR 래치는 두개의 사용 가능한 상태를 가짐
        - Q가 1이고 Q̅가 0인 세트 상태
        - Q가 0이고 Q̅가 1인 리셋 상태
        - Q와 Q̅는 보수 관계
        - S와 R이 모두 1일 때는 Q와 Q̅가 모두 0이 되는 미정 상태를 가짐

| S | R | Q(t+1) : 다음 시간의 Q값 |
|:-:|:-:|:------------------:|
| 0 | 0 |   Q(t) (무변한 상태)    |
| 0 | 1 |     0 (리셋 상태)      |
| 1 | 0 |     1 (세트 상태)      |
| 1 | 1 |       미정 상태        |

- 래치에서 1비트 정보를 보관하는 원리
    - 비트 값의 저장이라는 것은 무엇인가?
        - 입력을 통해 0이나 1이라는 값을 기억 소자에 주입하고 입력 신호가 사라진 후에도 그 값이 유지 되어있는 상태
        - 변하지 않고 남아있는 상태가 존재한다 -> 저장이 되어있다
        - 출력 단자에 전압이 1(High) 또는 0(Low) 상태로 전기적으로 상태를 유지하는 것을 뜻함
        - 래치는 이러한 전기적 상태를 유지하기 위해 내부 피드백 구조로 설계됨
- 내부 피드백 구조
    - 출력 상태를 유지하기 위해 출력 신호를 다시 입력으로 연결하는 구조
        - 출력이 다시 입력으로 돌아가는 순환 피드백 구조를 갖고 있음
        - 내부적으로 계속 입력과 출력을 수행하여 한번 만들어진 출력을 스스로 유지하게 함
        - 전원이 공급되면 일반적으로 Q는 0으로 Q는 1로 외부에서 리셋 상태로 초기화됨
        - S=1, R=0이면 두 번째 NOR 게이트는 Q값이 어떤 값이던 Q̅은 0출력
        - 첫 번째 NOR 게이트의 입력은 둘 다 0이 되어 Q는 1이 됨
        - 입력 신호가 사라지고 S와 R이 0, 0이 되어도 내부 피드백을 통해 인해 값을 유지
- NAND 게이트로 된 래치
    - NAND 게이트로된 SR래치는 NOR 게이트로된 SR래치와 수행 기능은 동일
        - 하지만 입력에 따른 출력의 동작은 반대

| S | R |    Q(t+1)     |
|:-:|:-:|:-------------:|
| 0 | 0 |     미정 상태     |
| 0 | 1 |   1 (세트 상태)   |
| 1 | 0 |   0 (리셋 상태)   |
| 1 | 1 | Q(t) (무변한 상태) |

- 제어입력을 가진 SR 래치(RS 플립플롭)
    - SR 래치는 비동기 순서논리회로
    - SR 래치는 비동기 특성으로 인한 문제가 존재함
        - 입력이 들어오기만 하면 래치가 동작하기 때문에
        - 제어가 불가능하며
        - 타이밍 맞추기가 어려움
    - 제어입력을 가진 RS 래치는 제어입력을 통해 입력을 받아들일지 말지 결정하여 이 문제를 해결함
    - RS 플립플롭의 문제점
        - C,S,R 이 모두 1일때 Q와 Q̅의 값이 모두 0이 되어 논리적 모순 상태가 됨
            - 어떤 값으로도 결정할 수 없는 상태가 됨
        - 제어입력이 다시 0으로 될 때, 다음 상태는 두 입력 S,R 중 어떤것이 1이 되는지에 따라 결정되기 됨
            - 게이트가 어떤 순서로 반응하느냐에 따라 출력값이 결정되어 예측이 불가능해짐
        - 피드백 루프가 깨지게 되어 회로가 상태를 유지할 수 없음

| C | S | R | Q의 다음 상태 |
|---|---|---|----------|
| 0 | X | X | 무변화상태    |
| 1 | 0 | 0 | 무변화상태    |
| 1 | 0 | 1 | 0 (리셋상태) |
| 1 | 1 | 0 | 1 (셋트상태) |
| 1 | 1 | 1 | 미정상태     |

- D 플립플롭의 개요
    - RS 플립플롭의 문제점을 해결하기 위해 미정상태라는 불필요한 상태를 제거함
        - RS플립플롭의 S는 입력 D로, 입력 R은 입력 D의 보수로 들어감
        - D의 값에 따라 플립플롭에서 유지할 값이 결정됨

| C | D | Q의 다음 상태 |
|---|---|----------|
| 0 | X | 무변화상태    |
| 1 | 0 | 0 (리셋상태) |
| 1 | 1 | 1 (셋트상태) |

- JK 플립플롭의 동작원리와 특성
    - 입력 J와 K는 RS 플립플롭의 S와 R에 대응
    - J와 K가 모두 1인 때를 제외하고는 RS 플립플롭과 동일
    - J,K가 모두 1인 경우, 한 클럭 펄스 뒤의 다음 상태는 현재 상태의 보수가 됨
        - Q(t) = 1이, Q(t+1) = 0
        - Q(t) = 0이, Q(t+1) = 1
    - 미정 상태로 인한 논리적 모순을 해결함
    - 하지만, J,K가 모두 1일 때 출력으로 보수를 취한 이후에도 클럭 펄스가 남아 있다면, 반복적으로 보수를 취하는 문제를 발생

| C | J | K | Q의 다음 상태 |
|---|---|---|----------|
| 0 | X | X | 무변화상태    |
| 1 | 0 | 0 | 무변화상태    |
| 1 | 0 | 1 | 리셋상태     |
| 1 | 1 | 0 | 셋트상태     |
| 1 | 1 | 1 | 보수(𝑄̅)  |

- T플립플롭의 개요
    - JK 플립플롭의 변형으로 두 입력을 하나로 묶은 형태
    - T는 상태를 반전한다는 토글(Toggle)에서 유래
        - 기존 값을 반전하는 기능만 있기 때문에 외부에서 Q를 초기화 해야함

| T | Q의 다음 상태 |
|---|----------|
| 0 | 무변화상태    |
| 1 | 반전(Q̅)   |

### (3) 플립플롭의 트리거링

- 트리거
    - 플립플롭의 상태는 제어신호의 순간적인 변화에 따라 바뀜
        - 이 순간적인 변화를 트리거(trigger)라고 함
    - D 플립플롭은 제어입력으로 클럭 펄스가 사용되며, 클럭 펄스가 논리-1 레벨로 변할 때 마다 트리거됨
        - 클럭 펄스가 논리-1 레벨을 유지하는 동안에 데이터 입력의 변화에 따라 플립플롭의 출력 상태가 변함

- 클럭 펄스가 사용되는 플립플롭의 트리거 방법
    - 레벨 트리거(level trigger) 방법
        - 클럭 펄스가 논리-1인 동안 입력이 출력에 방향을 미침
    - 에지 트리거(edge trigger) 방법
        - 클럭 펄스의 에지, 즉, 상승에지나 하강 에지 동안에 입력이 출력에 영향을 미침
        - 상승 에지 - 클럭 펄스의 논리 상태가 논리-0에서 논리-1로 바뀌는 것
        - 하강 에지 - 클럭 펄스의 논리 상태가 논리-1에서 논리-0으로 바뀌는 것

| C | S | R | Q의 다음 상태 |
|---|---|---|----------|
| 0 | X | X | 무변화상태    |
| 1 | 0 | 0 | 무변화상태    |
| 1 | 0 | 1 | 0(리셋상태)  |
| 1 | 1 | 0 | 1(셋트상태)  |
| 1 | 1 | 1 | 미정상태     |

- 마스터-슬레이브 플립플롭
    - 주(Master)와 종(Slave)의 역살을 하는 두 개의 별도의 플립플롭으로 구성
    - 기존 플립플롭에 인버터를 추가하여 구성
    - 동작 원리
        - 클럭 펄스의 상승 에지에서 첫 번째 플립플롭인 마스터를 세트
        - 하강 에지에서 두 번째 플립플롭인 슬레이브에 신호를 전달하도록 구성

- RS 플립플롭을 이용한 마스터-슬레이브 플립플롭
    - 클럭펄스 C=1 일 때
        - 마스터 플립플롭은 클럭 입력이 1이 되어 활동 상태가 됨
        - 슬레이브 플립플롭은 활동 불능 상태가 됨
        - R과 S에 있던 정보가 마스터 플립플롭에 전달됨
    - 클럭펄스 C=0 일 때
        - 마스터 플립플롭은 클럭 입력이 0이어서 활동 불능 상태가 됨
        - 슬레이브 플립플롭의 클럭 입력은 1이 되어 활동 상태가 됨
        - Q는 Y와 같고 Q̅는 Y̅와 같아 짐
        - 이를 통해 마스터와 슬레이브는 분리됨
- D 플립플롭을 이용한 마스터-슬레이브 플립플롭
    - 클럭펄스 C=1 일 때
        - 마스터 플립플롭은 클럭 입력이 1이 되어 활동 상태가 됨
        - 슬레이브 플립플롭은 활동 불능 상태가 됨
    - 클럭펄스 C=0 일 때
        - 마스터 플립플롭은 클럭 입력이 0이어서 활동 불능 상태가 됨
        - 슬레이브 플립플롭의 클럭 입력은 1이 되어 활동 상태가 됨
    - 동작 흐름 (초기 상태는 리셋으로 가정)
        - 첫 번째 클럭 펄스의 상승 에지 시점
            - 마스터 플립플롭은 활동 상태
            - 이때 슬레이브 플립플롭은 활동 불능
            - 입력 D=1 이기 때문에 출력 Y=1
        - 첫 번째 클럭 펄스의 하강 에지 시점
            - 슬레이브 플립플롭은 활동 상태
            - 마스터 플립플롭은 활동 불능 상태
            - 마스터 플립플롭의 출력 Y=1이 슬레이브에 전달
            - Q는 1상태가 됨
            - D=0이 되어도 마스터는 다음 상승 에지 때 까지 출력에 관여하지 못함
- JK 플립플롭을 이용한 마스터-슬레이브 플립플롭
    - J,K의 입력은 상승 에지에서 마스터 플립플롭에 하강 에지에서 슬레이브 플립플롭에 전달
    - J,K의 입력은 클럭 펄스의 상승 에지에서 입력되고 하강 에지가 될 때 까지 출력에는 나타나지 않음
    - 전체 플립플롭의 출력은 클럭펄스의 하강 에지에서 나타남
    - 동작흐름(초기 상태는 리셋으로 가정)
        - 첫 번째 클럭 펄스의 상승 에지 시점
            - 마스터 플립플롭은 활동 상태(J,K 둘 다 1이므로 반전)
            - 출력 Y=1
        - 첫 번째 클럭 펄스의 하강 에지 시점
            - 슬레이브 플립플롭은 활동 상태(Y=1, Y̅=0)
            - 출력 Q=1
        - 두 번째 클럭 펄스의 상승과 하강 에지 시점
            - 마스터 플립플롭 Y=1, 슬레이브 플립플롭 Q=1
        - 세 번째 클럭 펄스의 상승과 하강 에지 시점
            - 마스터 플립플롭 Y=0, 슬레이브 플립플롭 Q=0
            - 이 후 부터 클럭의 상승과 에지에서 마스터와 슬레이브가 활동, 비 활동 상태로 동작
